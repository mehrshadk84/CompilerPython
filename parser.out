Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> decl_or_stmt_list
Rule 2     decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt
Rule 3     decl_or_stmt_list -> decl_or_stmt
Rule 4     decl_or_stmt -> var_decl
Rule 5     decl_or_stmt -> func_decl
Rule 6     decl_or_stmt -> statement
Rule 7     var_decl -> type ID SEMICOLON
Rule 8     var_decl -> type ID ASSIGN expr SEMICOLON
Rule 9     var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON
Rule 10    type -> INT
Rule 11    type -> FLOAT
Rule 12    type -> BOOL
Rule 13    type -> CHAR
Rule 14    type -> STRING
Rule 15    func_decl -> FUNC ID LPAREN param_list_opt RPAREN block
Rule 16    param_list_opt -> param_list
Rule 17    param_list_opt -> empty
Rule 18    param_list -> param_list COMMA param
Rule 19    param_list -> param
Rule 20    param -> type ID
Rule 21    block -> LBRACE decl_or_stmt_list RBRACE
Rule 22    statement -> assignment SEMICOLON
Rule 23    statement -> if_stmt
Rule 24    statement -> while_stmt
Rule 25    statement -> for_stmt
Rule 26    statement -> io_stmt SEMICOLON
Rule 27    statement -> return_stmt SEMICOLON
Rule 28    statement -> BREAK SEMICOLON
Rule 29    statement -> CONTINUE SEMICOLON
Rule 30    statement -> block
Rule 31    assignment -> location ASSIGN expr
Rule 32    location -> ID
Rule 33    location -> ID LBRACKET expr RBRACKET
Rule 34    if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt
Rule 35    elif_part -> ELIF LPAREN expr RPAREN block elif_part
Rule 36    elif_part -> empty
Rule 37    else_part_opt -> ELSE block
Rule 38    else_part_opt -> empty
Rule 39    while_stmt -> WHILE LPAREN expr RPAREN block
Rule 40    for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block
Rule 41    io_stmt -> PRINT LPAREN expr RPAREN
Rule 42    io_stmt -> INPUT LPAREN ID RPAREN
Rule 43    return_stmt -> RETURN expr
Rule 44    return_stmt -> RETURN
Rule 45    expr -> logic_or_expr
Rule 46    logic_or_expr -> logic_or_expr OR logic_and_expr
Rule 47    logic_or_expr -> logic_and_expr
Rule 48    logic_and_expr -> logic_and_expr AND equality_expr
Rule 49    logic_and_expr -> equality_expr
Rule 50    equality_expr -> equality_expr EQ relational_expr
Rule 51    equality_expr -> equality_expr NE relational_expr
Rule 52    equality_expr -> relational_expr
Rule 53    relational_expr -> relational_expr LT additive_expr
Rule 54    relational_expr -> relational_expr LE additive_expr
Rule 55    relational_expr -> relational_expr GT additive_expr
Rule 56    relational_expr -> relational_expr GE additive_expr
Rule 57    relational_expr -> additive_expr
Rule 58    additive_expr -> additive_expr PLUS term
Rule 59    additive_expr -> additive_expr MINUS term
Rule 60    additive_expr -> term
Rule 61    term -> term TIMES factor
Rule 62    term -> term DIVIDE factor
Rule 63    term -> term MOD factor
Rule 64    term -> factor
Rule 65    factor -> NOT factor
Rule 66    factor -> MINUS factor
Rule 67    factor -> LPAREN expr RPAREN
Rule 68    factor -> INT_LITERAL
Rule 69    factor -> FLOAT_LITERAL
Rule 70    factor -> TRUE
Rule 71    factor -> FALSE
Rule 72    factor -> CHAR_LITERAL
Rule 73    factor -> STRING_LITERAL
Rule 74    factor -> location
Rule 75    factor -> ID LPAREN arg_list_opt RPAREN
Rule 76    arg_list_opt -> arg_list
Rule 77    arg_list_opt -> empty
Rule 78    arg_list -> arg_list COMMA expr
Rule 79    arg_list -> expr
Rule 80    empty -> <empty>

Terminals, with rules where they appear

AND                  : 48
ASSIGN               : 8 31
BOOL                 : 12
BREAK                : 28
CHAR                 : 13
CHAR_LITERAL         : 72
COMMA                : 18 78
CONTINUE             : 29
DIVIDE               : 62
ELIF                 : 35
ELSE                 : 37
EQ                   : 50
FALSE                : 71
FLOAT                : 11
FLOAT_LITERAL        : 69
FOR                  : 40
FUNC                 : 15
GE                   : 56
GT                   : 55
ID                   : 7 8 9 15 20 32 33 42 75
IF                   : 34
INPUT                : 42
INT                  : 10
INT_LITERAL          : 9 68
LBRACE               : 21
LBRACKET             : 9 33
LE                   : 54
LPAREN               : 15 34 35 39 40 41 42 67 75
LT                   : 53
MINUS                : 59 66
MOD                  : 63
NE                   : 51
NOT                  : 65
OR                   : 46
PLUS                 : 58
PRINT                : 41
RBRACE               : 21
RBRACKET             : 9 33
RETURN               : 43 44
RPAREN               : 15 34 35 39 40 41 42 67 75
SEMICOLON            : 7 8 9 22 26 27 28 29 40 40
STRING               : 14
STRING_LITERAL       : 73
TIMES                : 61
TRUE                 : 70
WHILE                : 39
error                : 

Nonterminals, with rules where they appear

additive_expr        : 53 54 55 56 57 58 59
arg_list             : 76 78
arg_list_opt         : 75
assignment           : 22 40 40
block                : 15 30 34 35 37 39 40
decl_or_stmt         : 2 3
decl_or_stmt_list    : 1 2 21
elif_part            : 34 35
else_part_opt        : 34
empty                : 17 36 38 77
equality_expr        : 48 49 50 51
expr                 : 8 31 33 34 35 39 40 41 43 67 78 79
factor               : 61 62 63 64 65 66
for_stmt             : 25
func_decl            : 5
if_stmt              : 23
io_stmt              : 26
location             : 31 74
logic_and_expr       : 46 47 48
logic_or_expr        : 45 46
param                : 18 19
param_list           : 16 18
param_list_opt       : 15
program              : 0
relational_expr      : 50 51 52 53 54 55 56
return_stmt          : 27
statement            : 6
term                 : 58 59 60 61 62 63
type                 : 7 8 9 20
var_decl             : 4
while_stmt           : 24

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . decl_or_stmt_list
    (2) decl_or_stmt_list -> . decl_or_stmt_list decl_or_stmt
    (3) decl_or_stmt_list -> . decl_or_stmt
    (4) decl_or_stmt -> . var_decl
    (5) decl_or_stmt -> . func_decl
    (6) decl_or_stmt -> . statement
    (7) var_decl -> . type ID SEMICOLON
    (8) var_decl -> . type ID ASSIGN expr SEMICOLON
    (9) var_decl -> . type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON
    (15) func_decl -> . FUNC ID LPAREN param_list_opt RPAREN block
    (22) statement -> . assignment SEMICOLON
    (23) statement -> . if_stmt
    (24) statement -> . while_stmt
    (25) statement -> . for_stmt
    (26) statement -> . io_stmt SEMICOLON
    (27) statement -> . return_stmt SEMICOLON
    (28) statement -> . BREAK SEMICOLON
    (29) statement -> . CONTINUE SEMICOLON
    (30) statement -> . block
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . BOOL
    (13) type -> . CHAR
    (14) type -> . STRING
    (31) assignment -> . location ASSIGN expr
    (34) if_stmt -> . IF LPAREN expr RPAREN block elif_part else_part_opt
    (39) while_stmt -> . WHILE LPAREN expr RPAREN block
    (40) for_stmt -> . FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block
    (41) io_stmt -> . PRINT LPAREN expr RPAREN
    (42) io_stmt -> . INPUT LPAREN ID RPAREN
    (43) return_stmt -> . RETURN expr
    (44) return_stmt -> . RETURN
    (21) block -> . LBRACE decl_or_stmt_list RBRACE
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    FUNC            shift and go to state 9
    BREAK           shift and go to state 17
    CONTINUE        shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 21
    CHAR            shift and go to state 22
    STRING          shift and go to state 23
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    INPUT           shift and go to state 29
    RETURN          shift and go to state 30
    LBRACE          shift and go to state 31
    ID              shift and go to state 8

    program                        shift and go to state 1
    decl_or_stmt_list              shift and go to state 2
    decl_or_stmt                   shift and go to state 3
    var_decl                       shift and go to state 4
    func_decl                      shift and go to state 5
    statement                      shift and go to state 6
    type                           shift and go to state 7
    block                          shift and go to state 10
    assignment                     shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    for_stmt                       shift and go to state 14
    io_stmt                        shift and go to state 15
    return_stmt                    shift and go to state 16
    location                       shift and go to state 24

state 1

    (0) S' -> program .



state 2

    (1) program -> decl_or_stmt_list .
    (2) decl_or_stmt_list -> decl_or_stmt_list . decl_or_stmt
    (4) decl_or_stmt -> . var_decl
    (5) decl_or_stmt -> . func_decl
    (6) decl_or_stmt -> . statement
    (7) var_decl -> . type ID SEMICOLON
    (8) var_decl -> . type ID ASSIGN expr SEMICOLON
    (9) var_decl -> . type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON
    (15) func_decl -> . FUNC ID LPAREN param_list_opt RPAREN block
    (22) statement -> . assignment SEMICOLON
    (23) statement -> . if_stmt
    (24) statement -> . while_stmt
    (25) statement -> . for_stmt
    (26) statement -> . io_stmt SEMICOLON
    (27) statement -> . return_stmt SEMICOLON
    (28) statement -> . BREAK SEMICOLON
    (29) statement -> . CONTINUE SEMICOLON
    (30) statement -> . block
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . BOOL
    (13) type -> . CHAR
    (14) type -> . STRING
    (31) assignment -> . location ASSIGN expr
    (34) if_stmt -> . IF LPAREN expr RPAREN block elif_part else_part_opt
    (39) while_stmt -> . WHILE LPAREN expr RPAREN block
    (40) for_stmt -> . FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block
    (41) io_stmt -> . PRINT LPAREN expr RPAREN
    (42) io_stmt -> . INPUT LPAREN ID RPAREN
    (43) return_stmt -> . RETURN expr
    (44) return_stmt -> . RETURN
    (21) block -> . LBRACE decl_or_stmt_list RBRACE
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    $end            reduce using rule 1 (program -> decl_or_stmt_list .)
    FUNC            shift and go to state 9
    BREAK           shift and go to state 17
    CONTINUE        shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 21
    CHAR            shift and go to state 22
    STRING          shift and go to state 23
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    INPUT           shift and go to state 29
    RETURN          shift and go to state 30
    LBRACE          shift and go to state 31
    ID              shift and go to state 8

    decl_or_stmt                   shift and go to state 32
    var_decl                       shift and go to state 4
    func_decl                      shift and go to state 5
    statement                      shift and go to state 6
    type                           shift and go to state 7
    block                          shift and go to state 10
    assignment                     shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    for_stmt                       shift and go to state 14
    io_stmt                        shift and go to state 15
    return_stmt                    shift and go to state 16
    location                       shift and go to state 24

state 3

    (3) decl_or_stmt_list -> decl_or_stmt .

    FUNC            reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    BREAK           reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    CONTINUE        reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    INT             reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    FLOAT           reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    BOOL            reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    CHAR            reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    STRING          reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    IF              reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    WHILE           reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    FOR             reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    PRINT           reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    INPUT           reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    RETURN          reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    LBRACE          reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    ID              reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    $end            reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    RBRACE          reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)


state 4

    (4) decl_or_stmt -> var_decl .

    FUNC            reduce using rule 4 (decl_or_stmt -> var_decl .)
    BREAK           reduce using rule 4 (decl_or_stmt -> var_decl .)
    CONTINUE        reduce using rule 4 (decl_or_stmt -> var_decl .)
    INT             reduce using rule 4 (decl_or_stmt -> var_decl .)
    FLOAT           reduce using rule 4 (decl_or_stmt -> var_decl .)
    BOOL            reduce using rule 4 (decl_or_stmt -> var_decl .)
    CHAR            reduce using rule 4 (decl_or_stmt -> var_decl .)
    STRING          reduce using rule 4 (decl_or_stmt -> var_decl .)
    IF              reduce using rule 4 (decl_or_stmt -> var_decl .)
    WHILE           reduce using rule 4 (decl_or_stmt -> var_decl .)
    FOR             reduce using rule 4 (decl_or_stmt -> var_decl .)
    PRINT           reduce using rule 4 (decl_or_stmt -> var_decl .)
    INPUT           reduce using rule 4 (decl_or_stmt -> var_decl .)
    RETURN          reduce using rule 4 (decl_or_stmt -> var_decl .)
    LBRACE          reduce using rule 4 (decl_or_stmt -> var_decl .)
    ID              reduce using rule 4 (decl_or_stmt -> var_decl .)
    $end            reduce using rule 4 (decl_or_stmt -> var_decl .)
    RBRACE          reduce using rule 4 (decl_or_stmt -> var_decl .)


state 5

    (5) decl_or_stmt -> func_decl .

    FUNC            reduce using rule 5 (decl_or_stmt -> func_decl .)
    BREAK           reduce using rule 5 (decl_or_stmt -> func_decl .)
    CONTINUE        reduce using rule 5 (decl_or_stmt -> func_decl .)
    INT             reduce using rule 5 (decl_or_stmt -> func_decl .)
    FLOAT           reduce using rule 5 (decl_or_stmt -> func_decl .)
    BOOL            reduce using rule 5 (decl_or_stmt -> func_decl .)
    CHAR            reduce using rule 5 (decl_or_stmt -> func_decl .)
    STRING          reduce using rule 5 (decl_or_stmt -> func_decl .)
    IF              reduce using rule 5 (decl_or_stmt -> func_decl .)
    WHILE           reduce using rule 5 (decl_or_stmt -> func_decl .)
    FOR             reduce using rule 5 (decl_or_stmt -> func_decl .)
    PRINT           reduce using rule 5 (decl_or_stmt -> func_decl .)
    INPUT           reduce using rule 5 (decl_or_stmt -> func_decl .)
    RETURN          reduce using rule 5 (decl_or_stmt -> func_decl .)
    LBRACE          reduce using rule 5 (decl_or_stmt -> func_decl .)
    ID              reduce using rule 5 (decl_or_stmt -> func_decl .)
    $end            reduce using rule 5 (decl_or_stmt -> func_decl .)
    RBRACE          reduce using rule 5 (decl_or_stmt -> func_decl .)


state 6

    (6) decl_or_stmt -> statement .

    FUNC            reduce using rule 6 (decl_or_stmt -> statement .)
    BREAK           reduce using rule 6 (decl_or_stmt -> statement .)
    CONTINUE        reduce using rule 6 (decl_or_stmt -> statement .)
    INT             reduce using rule 6 (decl_or_stmt -> statement .)
    FLOAT           reduce using rule 6 (decl_or_stmt -> statement .)
    BOOL            reduce using rule 6 (decl_or_stmt -> statement .)
    CHAR            reduce using rule 6 (decl_or_stmt -> statement .)
    STRING          reduce using rule 6 (decl_or_stmt -> statement .)
    IF              reduce using rule 6 (decl_or_stmt -> statement .)
    WHILE           reduce using rule 6 (decl_or_stmt -> statement .)
    FOR             reduce using rule 6 (decl_or_stmt -> statement .)
    PRINT           reduce using rule 6 (decl_or_stmt -> statement .)
    INPUT           reduce using rule 6 (decl_or_stmt -> statement .)
    RETURN          reduce using rule 6 (decl_or_stmt -> statement .)
    LBRACE          reduce using rule 6 (decl_or_stmt -> statement .)
    ID              reduce using rule 6 (decl_or_stmt -> statement .)
    $end            reduce using rule 6 (decl_or_stmt -> statement .)
    RBRACE          reduce using rule 6 (decl_or_stmt -> statement .)


state 7

    (7) var_decl -> type . ID SEMICOLON
    (8) var_decl -> type . ID ASSIGN expr SEMICOLON
    (9) var_decl -> type . ID LBRACKET INT_LITERAL RBRACKET SEMICOLON

    ID              shift and go to state 33


state 8

    (32) location -> ID .
    (33) location -> ID . LBRACKET expr RBRACKET

    ASSIGN          reduce using rule 32 (location -> ID .)
    LBRACKET        shift and go to state 34


state 9

    (15) func_decl -> FUNC . ID LPAREN param_list_opt RPAREN block

    ID              shift and go to state 35


state 10

    (30) statement -> block .

    FUNC            reduce using rule 30 (statement -> block .)
    BREAK           reduce using rule 30 (statement -> block .)
    CONTINUE        reduce using rule 30 (statement -> block .)
    INT             reduce using rule 30 (statement -> block .)
    FLOAT           reduce using rule 30 (statement -> block .)
    BOOL            reduce using rule 30 (statement -> block .)
    CHAR            reduce using rule 30 (statement -> block .)
    STRING          reduce using rule 30 (statement -> block .)
    IF              reduce using rule 30 (statement -> block .)
    WHILE           reduce using rule 30 (statement -> block .)
    FOR             reduce using rule 30 (statement -> block .)
    PRINT           reduce using rule 30 (statement -> block .)
    INPUT           reduce using rule 30 (statement -> block .)
    RETURN          reduce using rule 30 (statement -> block .)
    LBRACE          reduce using rule 30 (statement -> block .)
    ID              reduce using rule 30 (statement -> block .)
    $end            reduce using rule 30 (statement -> block .)
    RBRACE          reduce using rule 30 (statement -> block .)


state 11

    (22) statement -> assignment . SEMICOLON

    SEMICOLON       shift and go to state 36


state 12

    (23) statement -> if_stmt .

    FUNC            reduce using rule 23 (statement -> if_stmt .)
    BREAK           reduce using rule 23 (statement -> if_stmt .)
    CONTINUE        reduce using rule 23 (statement -> if_stmt .)
    INT             reduce using rule 23 (statement -> if_stmt .)
    FLOAT           reduce using rule 23 (statement -> if_stmt .)
    BOOL            reduce using rule 23 (statement -> if_stmt .)
    CHAR            reduce using rule 23 (statement -> if_stmt .)
    STRING          reduce using rule 23 (statement -> if_stmt .)
    IF              reduce using rule 23 (statement -> if_stmt .)
    WHILE           reduce using rule 23 (statement -> if_stmt .)
    FOR             reduce using rule 23 (statement -> if_stmt .)
    PRINT           reduce using rule 23 (statement -> if_stmt .)
    INPUT           reduce using rule 23 (statement -> if_stmt .)
    RETURN          reduce using rule 23 (statement -> if_stmt .)
    LBRACE          reduce using rule 23 (statement -> if_stmt .)
    ID              reduce using rule 23 (statement -> if_stmt .)
    $end            reduce using rule 23 (statement -> if_stmt .)
    RBRACE          reduce using rule 23 (statement -> if_stmt .)


state 13

    (24) statement -> while_stmt .

    FUNC            reduce using rule 24 (statement -> while_stmt .)
    BREAK           reduce using rule 24 (statement -> while_stmt .)
    CONTINUE        reduce using rule 24 (statement -> while_stmt .)
    INT             reduce using rule 24 (statement -> while_stmt .)
    FLOAT           reduce using rule 24 (statement -> while_stmt .)
    BOOL            reduce using rule 24 (statement -> while_stmt .)
    CHAR            reduce using rule 24 (statement -> while_stmt .)
    STRING          reduce using rule 24 (statement -> while_stmt .)
    IF              reduce using rule 24 (statement -> while_stmt .)
    WHILE           reduce using rule 24 (statement -> while_stmt .)
    FOR             reduce using rule 24 (statement -> while_stmt .)
    PRINT           reduce using rule 24 (statement -> while_stmt .)
    INPUT           reduce using rule 24 (statement -> while_stmt .)
    RETURN          reduce using rule 24 (statement -> while_stmt .)
    LBRACE          reduce using rule 24 (statement -> while_stmt .)
    ID              reduce using rule 24 (statement -> while_stmt .)
    $end            reduce using rule 24 (statement -> while_stmt .)
    RBRACE          reduce using rule 24 (statement -> while_stmt .)


state 14

    (25) statement -> for_stmt .

    FUNC            reduce using rule 25 (statement -> for_stmt .)
    BREAK           reduce using rule 25 (statement -> for_stmt .)
    CONTINUE        reduce using rule 25 (statement -> for_stmt .)
    INT             reduce using rule 25 (statement -> for_stmt .)
    FLOAT           reduce using rule 25 (statement -> for_stmt .)
    BOOL            reduce using rule 25 (statement -> for_stmt .)
    CHAR            reduce using rule 25 (statement -> for_stmt .)
    STRING          reduce using rule 25 (statement -> for_stmt .)
    IF              reduce using rule 25 (statement -> for_stmt .)
    WHILE           reduce using rule 25 (statement -> for_stmt .)
    FOR             reduce using rule 25 (statement -> for_stmt .)
    PRINT           reduce using rule 25 (statement -> for_stmt .)
    INPUT           reduce using rule 25 (statement -> for_stmt .)
    RETURN          reduce using rule 25 (statement -> for_stmt .)
    LBRACE          reduce using rule 25 (statement -> for_stmt .)
    ID              reduce using rule 25 (statement -> for_stmt .)
    $end            reduce using rule 25 (statement -> for_stmt .)
    RBRACE          reduce using rule 25 (statement -> for_stmt .)


state 15

    (26) statement -> io_stmt . SEMICOLON

    SEMICOLON       shift and go to state 37


state 16

    (27) statement -> return_stmt . SEMICOLON

    SEMICOLON       shift and go to state 38


state 17

    (28) statement -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 39


state 18

    (29) statement -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 40


state 19

    (10) type -> INT .

    ID              reduce using rule 10 (type -> INT .)


state 20

    (11) type -> FLOAT .

    ID              reduce using rule 11 (type -> FLOAT .)


state 21

    (12) type -> BOOL .

    ID              reduce using rule 12 (type -> BOOL .)


state 22

    (13) type -> CHAR .

    ID              reduce using rule 13 (type -> CHAR .)


state 23

    (14) type -> STRING .

    ID              reduce using rule 14 (type -> STRING .)


state 24

    (31) assignment -> location . ASSIGN expr

    ASSIGN          shift and go to state 41


state 25

    (34) if_stmt -> IF . LPAREN expr RPAREN block elif_part else_part_opt

    LPAREN          shift and go to state 42


state 26

    (39) while_stmt -> WHILE . LPAREN expr RPAREN block

    LPAREN          shift and go to state 43


state 27

    (40) for_stmt -> FOR . LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block

    LPAREN          shift and go to state 44


state 28

    (41) io_stmt -> PRINT . LPAREN expr RPAREN

    LPAREN          shift and go to state 45


state 29

    (42) io_stmt -> INPUT . LPAREN ID RPAREN

    LPAREN          shift and go to state 46


state 30

    (43) return_stmt -> RETURN . expr
    (44) return_stmt -> RETURN .
    (45) expr -> . logic_or_expr
    (46) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (47) logic_or_expr -> . logic_and_expr
    (48) logic_and_expr -> . logic_and_expr AND equality_expr
    (49) logic_and_expr -> . equality_expr
    (50) equality_expr -> . equality_expr EQ relational_expr
    (51) equality_expr -> . equality_expr NE relational_expr
    (52) equality_expr -> . relational_expr
    (53) relational_expr -> . relational_expr LT additive_expr
    (54) relational_expr -> . relational_expr LE additive_expr
    (55) relational_expr -> . relational_expr GT additive_expr
    (56) relational_expr -> . relational_expr GE additive_expr
    (57) relational_expr -> . additive_expr
    (58) additive_expr -> . additive_expr PLUS term
    (59) additive_expr -> . additive_expr MINUS term
    (60) additive_expr -> . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    SEMICOLON       reduce using rule 44 (return_stmt -> RETURN .)
    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    expr                           shift and go to state 47
    logic_or_expr                  shift and go to state 48
    logic_and_expr                 shift and go to state 49
    equality_expr                  shift and go to state 50
    relational_expr                shift and go to state 51
    additive_expr                  shift and go to state 52
    term                           shift and go to state 53
    factor                         shift and go to state 55
    location                       shift and go to state 64

state 31

    (21) block -> LBRACE . decl_or_stmt_list RBRACE
    (2) decl_or_stmt_list -> . decl_or_stmt_list decl_or_stmt
    (3) decl_or_stmt_list -> . decl_or_stmt
    (4) decl_or_stmt -> . var_decl
    (5) decl_or_stmt -> . func_decl
    (6) decl_or_stmt -> . statement
    (7) var_decl -> . type ID SEMICOLON
    (8) var_decl -> . type ID ASSIGN expr SEMICOLON
    (9) var_decl -> . type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON
    (15) func_decl -> . FUNC ID LPAREN param_list_opt RPAREN block
    (22) statement -> . assignment SEMICOLON
    (23) statement -> . if_stmt
    (24) statement -> . while_stmt
    (25) statement -> . for_stmt
    (26) statement -> . io_stmt SEMICOLON
    (27) statement -> . return_stmt SEMICOLON
    (28) statement -> . BREAK SEMICOLON
    (29) statement -> . CONTINUE SEMICOLON
    (30) statement -> . block
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . BOOL
    (13) type -> . CHAR
    (14) type -> . STRING
    (31) assignment -> . location ASSIGN expr
    (34) if_stmt -> . IF LPAREN expr RPAREN block elif_part else_part_opt
    (39) while_stmt -> . WHILE LPAREN expr RPAREN block
    (40) for_stmt -> . FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block
    (41) io_stmt -> . PRINT LPAREN expr RPAREN
    (42) io_stmt -> . INPUT LPAREN ID RPAREN
    (43) return_stmt -> . RETURN expr
    (44) return_stmt -> . RETURN
    (21) block -> . LBRACE decl_or_stmt_list RBRACE
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    FUNC            shift and go to state 9
    BREAK           shift and go to state 17
    CONTINUE        shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 21
    CHAR            shift and go to state 22
    STRING          shift and go to state 23
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    INPUT           shift and go to state 29
    RETURN          shift and go to state 30
    LBRACE          shift and go to state 31
    ID              shift and go to state 8

    decl_or_stmt_list              shift and go to state 66
    decl_or_stmt                   shift and go to state 3
    var_decl                       shift and go to state 4
    func_decl                      shift and go to state 5
    statement                      shift and go to state 6
    type                           shift and go to state 7
    block                          shift and go to state 10
    assignment                     shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    for_stmt                       shift and go to state 14
    io_stmt                        shift and go to state 15
    return_stmt                    shift and go to state 16
    location                       shift and go to state 24

state 32

    (2) decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .

    FUNC            reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    BREAK           reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    CONTINUE        reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    INT             reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    FLOAT           reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    BOOL            reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    CHAR            reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    STRING          reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    IF              reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    WHILE           reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    FOR             reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    PRINT           reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    INPUT           reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    RETURN          reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    LBRACE          reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    ID              reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    $end            reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    RBRACE          reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)


state 33

    (7) var_decl -> type ID . SEMICOLON
    (8) var_decl -> type ID . ASSIGN expr SEMICOLON
    (9) var_decl -> type ID . LBRACKET INT_LITERAL RBRACKET SEMICOLON

    SEMICOLON       shift and go to state 67
    ASSIGN          shift and go to state 68
    LBRACKET        shift and go to state 69


state 34

    (33) location -> ID LBRACKET . expr RBRACKET
    (45) expr -> . logic_or_expr
    (46) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (47) logic_or_expr -> . logic_and_expr
    (48) logic_and_expr -> . logic_and_expr AND equality_expr
    (49) logic_and_expr -> . equality_expr
    (50) equality_expr -> . equality_expr EQ relational_expr
    (51) equality_expr -> . equality_expr NE relational_expr
    (52) equality_expr -> . relational_expr
    (53) relational_expr -> . relational_expr LT additive_expr
    (54) relational_expr -> . relational_expr LE additive_expr
    (55) relational_expr -> . relational_expr GT additive_expr
    (56) relational_expr -> . relational_expr GE additive_expr
    (57) relational_expr -> . additive_expr
    (58) additive_expr -> . additive_expr PLUS term
    (59) additive_expr -> . additive_expr MINUS term
    (60) additive_expr -> . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    expr                           shift and go to state 70
    logic_or_expr                  shift and go to state 48
    logic_and_expr                 shift and go to state 49
    equality_expr                  shift and go to state 50
    relational_expr                shift and go to state 51
    additive_expr                  shift and go to state 52
    term                           shift and go to state 53
    factor                         shift and go to state 55
    location                       shift and go to state 64

state 35

    (15) func_decl -> FUNC ID . LPAREN param_list_opt RPAREN block

    LPAREN          shift and go to state 71


state 36

    (22) statement -> assignment SEMICOLON .

    FUNC            reduce using rule 22 (statement -> assignment SEMICOLON .)
    BREAK           reduce using rule 22 (statement -> assignment SEMICOLON .)
    CONTINUE        reduce using rule 22 (statement -> assignment SEMICOLON .)
    INT             reduce using rule 22 (statement -> assignment SEMICOLON .)
    FLOAT           reduce using rule 22 (statement -> assignment SEMICOLON .)
    BOOL            reduce using rule 22 (statement -> assignment SEMICOLON .)
    CHAR            reduce using rule 22 (statement -> assignment SEMICOLON .)
    STRING          reduce using rule 22 (statement -> assignment SEMICOLON .)
    IF              reduce using rule 22 (statement -> assignment SEMICOLON .)
    WHILE           reduce using rule 22 (statement -> assignment SEMICOLON .)
    FOR             reduce using rule 22 (statement -> assignment SEMICOLON .)
    PRINT           reduce using rule 22 (statement -> assignment SEMICOLON .)
    INPUT           reduce using rule 22 (statement -> assignment SEMICOLON .)
    RETURN          reduce using rule 22 (statement -> assignment SEMICOLON .)
    LBRACE          reduce using rule 22 (statement -> assignment SEMICOLON .)
    ID              reduce using rule 22 (statement -> assignment SEMICOLON .)
    $end            reduce using rule 22 (statement -> assignment SEMICOLON .)
    RBRACE          reduce using rule 22 (statement -> assignment SEMICOLON .)


state 37

    (26) statement -> io_stmt SEMICOLON .

    FUNC            reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    BREAK           reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    CONTINUE        reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    INT             reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    FLOAT           reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    BOOL            reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    CHAR            reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    STRING          reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    IF              reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    WHILE           reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    FOR             reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    PRINT           reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    INPUT           reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    RETURN          reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    LBRACE          reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    ID              reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    $end            reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    RBRACE          reduce using rule 26 (statement -> io_stmt SEMICOLON .)


state 38

    (27) statement -> return_stmt SEMICOLON .

    FUNC            reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    BREAK           reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    CONTINUE        reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    INT             reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    FLOAT           reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    BOOL            reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    CHAR            reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    STRING          reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    IF              reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    WHILE           reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    FOR             reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    PRINT           reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    INPUT           reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    RETURN          reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    LBRACE          reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    ID              reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    $end            reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    RBRACE          reduce using rule 27 (statement -> return_stmt SEMICOLON .)


state 39

    (28) statement -> BREAK SEMICOLON .

    FUNC            reduce using rule 28 (statement -> BREAK SEMICOLON .)
    BREAK           reduce using rule 28 (statement -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 28 (statement -> BREAK SEMICOLON .)
    INT             reduce using rule 28 (statement -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 28 (statement -> BREAK SEMICOLON .)
    BOOL            reduce using rule 28 (statement -> BREAK SEMICOLON .)
    CHAR            reduce using rule 28 (statement -> BREAK SEMICOLON .)
    STRING          reduce using rule 28 (statement -> BREAK SEMICOLON .)
    IF              reduce using rule 28 (statement -> BREAK SEMICOLON .)
    WHILE           reduce using rule 28 (statement -> BREAK SEMICOLON .)
    FOR             reduce using rule 28 (statement -> BREAK SEMICOLON .)
    PRINT           reduce using rule 28 (statement -> BREAK SEMICOLON .)
    INPUT           reduce using rule 28 (statement -> BREAK SEMICOLON .)
    RETURN          reduce using rule 28 (statement -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 28 (statement -> BREAK SEMICOLON .)
    ID              reduce using rule 28 (statement -> BREAK SEMICOLON .)
    $end            reduce using rule 28 (statement -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 28 (statement -> BREAK SEMICOLON .)


state 40

    (29) statement -> CONTINUE SEMICOLON .

    FUNC            reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    INT             reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    BOOL            reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    CHAR            reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    STRING          reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    IF              reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    PRINT           reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    INPUT           reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    LBRACE          reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    ID              reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    $end            reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    RBRACE          reduce using rule 29 (statement -> CONTINUE SEMICOLON .)


state 41

    (31) assignment -> location ASSIGN . expr
    (45) expr -> . logic_or_expr
    (46) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (47) logic_or_expr -> . logic_and_expr
    (48) logic_and_expr -> . logic_and_expr AND equality_expr
    (49) logic_and_expr -> . equality_expr
    (50) equality_expr -> . equality_expr EQ relational_expr
    (51) equality_expr -> . equality_expr NE relational_expr
    (52) equality_expr -> . relational_expr
    (53) relational_expr -> . relational_expr LT additive_expr
    (54) relational_expr -> . relational_expr LE additive_expr
    (55) relational_expr -> . relational_expr GT additive_expr
    (56) relational_expr -> . relational_expr GE additive_expr
    (57) relational_expr -> . additive_expr
    (58) additive_expr -> . additive_expr PLUS term
    (59) additive_expr -> . additive_expr MINUS term
    (60) additive_expr -> . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    location                       shift and go to state 64
    expr                           shift and go to state 72
    logic_or_expr                  shift and go to state 48
    logic_and_expr                 shift and go to state 49
    equality_expr                  shift and go to state 50
    relational_expr                shift and go to state 51
    additive_expr                  shift and go to state 52
    term                           shift and go to state 53
    factor                         shift and go to state 55

state 42

    (34) if_stmt -> IF LPAREN . expr RPAREN block elif_part else_part_opt
    (45) expr -> . logic_or_expr
    (46) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (47) logic_or_expr -> . logic_and_expr
    (48) logic_and_expr -> . logic_and_expr AND equality_expr
    (49) logic_and_expr -> . equality_expr
    (50) equality_expr -> . equality_expr EQ relational_expr
    (51) equality_expr -> . equality_expr NE relational_expr
    (52) equality_expr -> . relational_expr
    (53) relational_expr -> . relational_expr LT additive_expr
    (54) relational_expr -> . relational_expr LE additive_expr
    (55) relational_expr -> . relational_expr GT additive_expr
    (56) relational_expr -> . relational_expr GE additive_expr
    (57) relational_expr -> . additive_expr
    (58) additive_expr -> . additive_expr PLUS term
    (59) additive_expr -> . additive_expr MINUS term
    (60) additive_expr -> . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    expr                           shift and go to state 73
    logic_or_expr                  shift and go to state 48
    logic_and_expr                 shift and go to state 49
    equality_expr                  shift and go to state 50
    relational_expr                shift and go to state 51
    additive_expr                  shift and go to state 52
    term                           shift and go to state 53
    factor                         shift and go to state 55
    location                       shift and go to state 64

state 43

    (39) while_stmt -> WHILE LPAREN . expr RPAREN block
    (45) expr -> . logic_or_expr
    (46) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (47) logic_or_expr -> . logic_and_expr
    (48) logic_and_expr -> . logic_and_expr AND equality_expr
    (49) logic_and_expr -> . equality_expr
    (50) equality_expr -> . equality_expr EQ relational_expr
    (51) equality_expr -> . equality_expr NE relational_expr
    (52) equality_expr -> . relational_expr
    (53) relational_expr -> . relational_expr LT additive_expr
    (54) relational_expr -> . relational_expr LE additive_expr
    (55) relational_expr -> . relational_expr GT additive_expr
    (56) relational_expr -> . relational_expr GE additive_expr
    (57) relational_expr -> . additive_expr
    (58) additive_expr -> . additive_expr PLUS term
    (59) additive_expr -> . additive_expr MINUS term
    (60) additive_expr -> . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    expr                           shift and go to state 74
    logic_or_expr                  shift and go to state 48
    logic_and_expr                 shift and go to state 49
    equality_expr                  shift and go to state 50
    relational_expr                shift and go to state 51
    additive_expr                  shift and go to state 52
    term                           shift and go to state 53
    factor                         shift and go to state 55
    location                       shift and go to state 64

state 44

    (40) for_stmt -> FOR LPAREN . assignment SEMICOLON expr SEMICOLON assignment RPAREN block
    (31) assignment -> . location ASSIGN expr
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    ID              shift and go to state 8

    assignment                     shift and go to state 75
    location                       shift and go to state 24

state 45

    (41) io_stmt -> PRINT LPAREN . expr RPAREN
    (45) expr -> . logic_or_expr
    (46) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (47) logic_or_expr -> . logic_and_expr
    (48) logic_and_expr -> . logic_and_expr AND equality_expr
    (49) logic_and_expr -> . equality_expr
    (50) equality_expr -> . equality_expr EQ relational_expr
    (51) equality_expr -> . equality_expr NE relational_expr
    (52) equality_expr -> . relational_expr
    (53) relational_expr -> . relational_expr LT additive_expr
    (54) relational_expr -> . relational_expr LE additive_expr
    (55) relational_expr -> . relational_expr GT additive_expr
    (56) relational_expr -> . relational_expr GE additive_expr
    (57) relational_expr -> . additive_expr
    (58) additive_expr -> . additive_expr PLUS term
    (59) additive_expr -> . additive_expr MINUS term
    (60) additive_expr -> . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    expr                           shift and go to state 76
    logic_or_expr                  shift and go to state 48
    logic_and_expr                 shift and go to state 49
    equality_expr                  shift and go to state 50
    relational_expr                shift and go to state 51
    additive_expr                  shift and go to state 52
    term                           shift and go to state 53
    factor                         shift and go to state 55
    location                       shift and go to state 64

state 46

    (42) io_stmt -> INPUT LPAREN . ID RPAREN

    ID              shift and go to state 77


state 47

    (43) return_stmt -> RETURN expr .

    SEMICOLON       reduce using rule 43 (return_stmt -> RETURN expr .)


state 48

    (45) expr -> logic_or_expr .
    (46) logic_or_expr -> logic_or_expr . OR logic_and_expr

    SEMICOLON       reduce using rule 45 (expr -> logic_or_expr .)
    RBRACKET        reduce using rule 45 (expr -> logic_or_expr .)
    RPAREN          reduce using rule 45 (expr -> logic_or_expr .)
    COMMA           reduce using rule 45 (expr -> logic_or_expr .)
    OR              shift and go to state 78


state 49

    (47) logic_or_expr -> logic_and_expr .
    (48) logic_and_expr -> logic_and_expr . AND equality_expr

    OR              reduce using rule 47 (logic_or_expr -> logic_and_expr .)
    SEMICOLON       reduce using rule 47 (logic_or_expr -> logic_and_expr .)
    RBRACKET        reduce using rule 47 (logic_or_expr -> logic_and_expr .)
    RPAREN          reduce using rule 47 (logic_or_expr -> logic_and_expr .)
    COMMA           reduce using rule 47 (logic_or_expr -> logic_and_expr .)
    AND             shift and go to state 79


state 50

    (49) logic_and_expr -> equality_expr .
    (50) equality_expr -> equality_expr . EQ relational_expr
    (51) equality_expr -> equality_expr . NE relational_expr

    AND             reduce using rule 49 (logic_and_expr -> equality_expr .)
    OR              reduce using rule 49 (logic_and_expr -> equality_expr .)
    SEMICOLON       reduce using rule 49 (logic_and_expr -> equality_expr .)
    RBRACKET        reduce using rule 49 (logic_and_expr -> equality_expr .)
    RPAREN          reduce using rule 49 (logic_and_expr -> equality_expr .)
    COMMA           reduce using rule 49 (logic_and_expr -> equality_expr .)
    EQ              shift and go to state 80
    NE              shift and go to state 81


state 51

    (52) equality_expr -> relational_expr .
    (53) relational_expr -> relational_expr . LT additive_expr
    (54) relational_expr -> relational_expr . LE additive_expr
    (55) relational_expr -> relational_expr . GT additive_expr
    (56) relational_expr -> relational_expr . GE additive_expr

    EQ              reduce using rule 52 (equality_expr -> relational_expr .)
    NE              reduce using rule 52 (equality_expr -> relational_expr .)
    AND             reduce using rule 52 (equality_expr -> relational_expr .)
    OR              reduce using rule 52 (equality_expr -> relational_expr .)
    SEMICOLON       reduce using rule 52 (equality_expr -> relational_expr .)
    RBRACKET        reduce using rule 52 (equality_expr -> relational_expr .)
    RPAREN          reduce using rule 52 (equality_expr -> relational_expr .)
    COMMA           reduce using rule 52 (equality_expr -> relational_expr .)
    LT              shift and go to state 82
    LE              shift and go to state 83
    GT              shift and go to state 84
    GE              shift and go to state 85


state 52

    (57) relational_expr -> additive_expr .
    (58) additive_expr -> additive_expr . PLUS term
    (59) additive_expr -> additive_expr . MINUS term

    LT              reduce using rule 57 (relational_expr -> additive_expr .)
    LE              reduce using rule 57 (relational_expr -> additive_expr .)
    GT              reduce using rule 57 (relational_expr -> additive_expr .)
    GE              reduce using rule 57 (relational_expr -> additive_expr .)
    EQ              reduce using rule 57 (relational_expr -> additive_expr .)
    NE              reduce using rule 57 (relational_expr -> additive_expr .)
    AND             reduce using rule 57 (relational_expr -> additive_expr .)
    OR              reduce using rule 57 (relational_expr -> additive_expr .)
    SEMICOLON       reduce using rule 57 (relational_expr -> additive_expr .)
    RBRACKET        reduce using rule 57 (relational_expr -> additive_expr .)
    RPAREN          reduce using rule 57 (relational_expr -> additive_expr .)
    COMMA           reduce using rule 57 (relational_expr -> additive_expr .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 53

    (60) additive_expr -> term .
    (61) term -> term . TIMES factor
    (62) term -> term . DIVIDE factor
    (63) term -> term . MOD factor

    PLUS            reduce using rule 60 (additive_expr -> term .)
    MINUS           reduce using rule 60 (additive_expr -> term .)
    LT              reduce using rule 60 (additive_expr -> term .)
    LE              reduce using rule 60 (additive_expr -> term .)
    GT              reduce using rule 60 (additive_expr -> term .)
    GE              reduce using rule 60 (additive_expr -> term .)
    EQ              reduce using rule 60 (additive_expr -> term .)
    NE              reduce using rule 60 (additive_expr -> term .)
    AND             reduce using rule 60 (additive_expr -> term .)
    OR              reduce using rule 60 (additive_expr -> term .)
    SEMICOLON       reduce using rule 60 (additive_expr -> term .)
    RBRACKET        reduce using rule 60 (additive_expr -> term .)
    RPAREN          reduce using rule 60 (additive_expr -> term .)
    COMMA           reduce using rule 60 (additive_expr -> term .)
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MOD             shift and go to state 90


state 54

    (66) factor -> MINUS . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    factor                         shift and go to state 91
    location                       shift and go to state 64

state 55

    (64) term -> factor .

    TIMES           reduce using rule 64 (term -> factor .)
    DIVIDE          reduce using rule 64 (term -> factor .)
    MOD             reduce using rule 64 (term -> factor .)
    PLUS            reduce using rule 64 (term -> factor .)
    MINUS           reduce using rule 64 (term -> factor .)
    LT              reduce using rule 64 (term -> factor .)
    LE              reduce using rule 64 (term -> factor .)
    GT              reduce using rule 64 (term -> factor .)
    GE              reduce using rule 64 (term -> factor .)
    EQ              reduce using rule 64 (term -> factor .)
    NE              reduce using rule 64 (term -> factor .)
    AND             reduce using rule 64 (term -> factor .)
    OR              reduce using rule 64 (term -> factor .)
    SEMICOLON       reduce using rule 64 (term -> factor .)
    RBRACKET        reduce using rule 64 (term -> factor .)
    RPAREN          reduce using rule 64 (term -> factor .)
    COMMA           reduce using rule 64 (term -> factor .)


state 56

    (65) factor -> NOT . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    factor                         shift and go to state 92
    location                       shift and go to state 64

state 57

    (67) factor -> LPAREN . expr RPAREN
    (45) expr -> . logic_or_expr
    (46) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (47) logic_or_expr -> . logic_and_expr
    (48) logic_and_expr -> . logic_and_expr AND equality_expr
    (49) logic_and_expr -> . equality_expr
    (50) equality_expr -> . equality_expr EQ relational_expr
    (51) equality_expr -> . equality_expr NE relational_expr
    (52) equality_expr -> . relational_expr
    (53) relational_expr -> . relational_expr LT additive_expr
    (54) relational_expr -> . relational_expr LE additive_expr
    (55) relational_expr -> . relational_expr GT additive_expr
    (56) relational_expr -> . relational_expr GE additive_expr
    (57) relational_expr -> . additive_expr
    (58) additive_expr -> . additive_expr PLUS term
    (59) additive_expr -> . additive_expr MINUS term
    (60) additive_expr -> . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    expr                           shift and go to state 93
    logic_or_expr                  shift and go to state 48
    logic_and_expr                 shift and go to state 49
    equality_expr                  shift and go to state 50
    relational_expr                shift and go to state 51
    additive_expr                  shift and go to state 52
    term                           shift and go to state 53
    factor                         shift and go to state 55
    location                       shift and go to state 64

state 58

    (68) factor -> INT_LITERAL .

    TIMES           reduce using rule 68 (factor -> INT_LITERAL .)
    DIVIDE          reduce using rule 68 (factor -> INT_LITERAL .)
    MOD             reduce using rule 68 (factor -> INT_LITERAL .)
    PLUS            reduce using rule 68 (factor -> INT_LITERAL .)
    MINUS           reduce using rule 68 (factor -> INT_LITERAL .)
    LT              reduce using rule 68 (factor -> INT_LITERAL .)
    LE              reduce using rule 68 (factor -> INT_LITERAL .)
    GT              reduce using rule 68 (factor -> INT_LITERAL .)
    GE              reduce using rule 68 (factor -> INT_LITERAL .)
    EQ              reduce using rule 68 (factor -> INT_LITERAL .)
    NE              reduce using rule 68 (factor -> INT_LITERAL .)
    AND             reduce using rule 68 (factor -> INT_LITERAL .)
    OR              reduce using rule 68 (factor -> INT_LITERAL .)
    SEMICOLON       reduce using rule 68 (factor -> INT_LITERAL .)
    RBRACKET        reduce using rule 68 (factor -> INT_LITERAL .)
    RPAREN          reduce using rule 68 (factor -> INT_LITERAL .)
    COMMA           reduce using rule 68 (factor -> INT_LITERAL .)


state 59

    (69) factor -> FLOAT_LITERAL .

    TIMES           reduce using rule 69 (factor -> FLOAT_LITERAL .)
    DIVIDE          reduce using rule 69 (factor -> FLOAT_LITERAL .)
    MOD             reduce using rule 69 (factor -> FLOAT_LITERAL .)
    PLUS            reduce using rule 69 (factor -> FLOAT_LITERAL .)
    MINUS           reduce using rule 69 (factor -> FLOAT_LITERAL .)
    LT              reduce using rule 69 (factor -> FLOAT_LITERAL .)
    LE              reduce using rule 69 (factor -> FLOAT_LITERAL .)
    GT              reduce using rule 69 (factor -> FLOAT_LITERAL .)
    GE              reduce using rule 69 (factor -> FLOAT_LITERAL .)
    EQ              reduce using rule 69 (factor -> FLOAT_LITERAL .)
    NE              reduce using rule 69 (factor -> FLOAT_LITERAL .)
    AND             reduce using rule 69 (factor -> FLOAT_LITERAL .)
    OR              reduce using rule 69 (factor -> FLOAT_LITERAL .)
    SEMICOLON       reduce using rule 69 (factor -> FLOAT_LITERAL .)
    RBRACKET        reduce using rule 69 (factor -> FLOAT_LITERAL .)
    RPAREN          reduce using rule 69 (factor -> FLOAT_LITERAL .)
    COMMA           reduce using rule 69 (factor -> FLOAT_LITERAL .)


state 60

    (70) factor -> TRUE .

    TIMES           reduce using rule 70 (factor -> TRUE .)
    DIVIDE          reduce using rule 70 (factor -> TRUE .)
    MOD             reduce using rule 70 (factor -> TRUE .)
    PLUS            reduce using rule 70 (factor -> TRUE .)
    MINUS           reduce using rule 70 (factor -> TRUE .)
    LT              reduce using rule 70 (factor -> TRUE .)
    LE              reduce using rule 70 (factor -> TRUE .)
    GT              reduce using rule 70 (factor -> TRUE .)
    GE              reduce using rule 70 (factor -> TRUE .)
    EQ              reduce using rule 70 (factor -> TRUE .)
    NE              reduce using rule 70 (factor -> TRUE .)
    AND             reduce using rule 70 (factor -> TRUE .)
    OR              reduce using rule 70 (factor -> TRUE .)
    SEMICOLON       reduce using rule 70 (factor -> TRUE .)
    RBRACKET        reduce using rule 70 (factor -> TRUE .)
    RPAREN          reduce using rule 70 (factor -> TRUE .)
    COMMA           reduce using rule 70 (factor -> TRUE .)


state 61

    (71) factor -> FALSE .

    TIMES           reduce using rule 71 (factor -> FALSE .)
    DIVIDE          reduce using rule 71 (factor -> FALSE .)
    MOD             reduce using rule 71 (factor -> FALSE .)
    PLUS            reduce using rule 71 (factor -> FALSE .)
    MINUS           reduce using rule 71 (factor -> FALSE .)
    LT              reduce using rule 71 (factor -> FALSE .)
    LE              reduce using rule 71 (factor -> FALSE .)
    GT              reduce using rule 71 (factor -> FALSE .)
    GE              reduce using rule 71 (factor -> FALSE .)
    EQ              reduce using rule 71 (factor -> FALSE .)
    NE              reduce using rule 71 (factor -> FALSE .)
    AND             reduce using rule 71 (factor -> FALSE .)
    OR              reduce using rule 71 (factor -> FALSE .)
    SEMICOLON       reduce using rule 71 (factor -> FALSE .)
    RBRACKET        reduce using rule 71 (factor -> FALSE .)
    RPAREN          reduce using rule 71 (factor -> FALSE .)
    COMMA           reduce using rule 71 (factor -> FALSE .)


state 62

    (72) factor -> CHAR_LITERAL .

    TIMES           reduce using rule 72 (factor -> CHAR_LITERAL .)
    DIVIDE          reduce using rule 72 (factor -> CHAR_LITERAL .)
    MOD             reduce using rule 72 (factor -> CHAR_LITERAL .)
    PLUS            reduce using rule 72 (factor -> CHAR_LITERAL .)
    MINUS           reduce using rule 72 (factor -> CHAR_LITERAL .)
    LT              reduce using rule 72 (factor -> CHAR_LITERAL .)
    LE              reduce using rule 72 (factor -> CHAR_LITERAL .)
    GT              reduce using rule 72 (factor -> CHAR_LITERAL .)
    GE              reduce using rule 72 (factor -> CHAR_LITERAL .)
    EQ              reduce using rule 72 (factor -> CHAR_LITERAL .)
    NE              reduce using rule 72 (factor -> CHAR_LITERAL .)
    AND             reduce using rule 72 (factor -> CHAR_LITERAL .)
    OR              reduce using rule 72 (factor -> CHAR_LITERAL .)
    SEMICOLON       reduce using rule 72 (factor -> CHAR_LITERAL .)
    RBRACKET        reduce using rule 72 (factor -> CHAR_LITERAL .)
    RPAREN          reduce using rule 72 (factor -> CHAR_LITERAL .)
    COMMA           reduce using rule 72 (factor -> CHAR_LITERAL .)


state 63

    (73) factor -> STRING_LITERAL .

    TIMES           reduce using rule 73 (factor -> STRING_LITERAL .)
    DIVIDE          reduce using rule 73 (factor -> STRING_LITERAL .)
    MOD             reduce using rule 73 (factor -> STRING_LITERAL .)
    PLUS            reduce using rule 73 (factor -> STRING_LITERAL .)
    MINUS           reduce using rule 73 (factor -> STRING_LITERAL .)
    LT              reduce using rule 73 (factor -> STRING_LITERAL .)
    LE              reduce using rule 73 (factor -> STRING_LITERAL .)
    GT              reduce using rule 73 (factor -> STRING_LITERAL .)
    GE              reduce using rule 73 (factor -> STRING_LITERAL .)
    EQ              reduce using rule 73 (factor -> STRING_LITERAL .)
    NE              reduce using rule 73 (factor -> STRING_LITERAL .)
    AND             reduce using rule 73 (factor -> STRING_LITERAL .)
    OR              reduce using rule 73 (factor -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 73 (factor -> STRING_LITERAL .)
    RBRACKET        reduce using rule 73 (factor -> STRING_LITERAL .)
    RPAREN          reduce using rule 73 (factor -> STRING_LITERAL .)
    COMMA           reduce using rule 73 (factor -> STRING_LITERAL .)


state 64

    (74) factor -> location .

    TIMES           reduce using rule 74 (factor -> location .)
    DIVIDE          reduce using rule 74 (factor -> location .)
    MOD             reduce using rule 74 (factor -> location .)
    PLUS            reduce using rule 74 (factor -> location .)
    MINUS           reduce using rule 74 (factor -> location .)
    LT              reduce using rule 74 (factor -> location .)
    LE              reduce using rule 74 (factor -> location .)
    GT              reduce using rule 74 (factor -> location .)
    GE              reduce using rule 74 (factor -> location .)
    EQ              reduce using rule 74 (factor -> location .)
    NE              reduce using rule 74 (factor -> location .)
    AND             reduce using rule 74 (factor -> location .)
    OR              reduce using rule 74 (factor -> location .)
    SEMICOLON       reduce using rule 74 (factor -> location .)
    RBRACKET        reduce using rule 74 (factor -> location .)
    RPAREN          reduce using rule 74 (factor -> location .)
    COMMA           reduce using rule 74 (factor -> location .)


state 65

    (75) factor -> ID . LPAREN arg_list_opt RPAREN
    (32) location -> ID .
    (33) location -> ID . LBRACKET expr RBRACKET

    LPAREN          shift and go to state 94
    TIMES           reduce using rule 32 (location -> ID .)
    DIVIDE          reduce using rule 32 (location -> ID .)
    MOD             reduce using rule 32 (location -> ID .)
    PLUS            reduce using rule 32 (location -> ID .)
    MINUS           reduce using rule 32 (location -> ID .)
    LT              reduce using rule 32 (location -> ID .)
    LE              reduce using rule 32 (location -> ID .)
    GT              reduce using rule 32 (location -> ID .)
    GE              reduce using rule 32 (location -> ID .)
    EQ              reduce using rule 32 (location -> ID .)
    NE              reduce using rule 32 (location -> ID .)
    AND             reduce using rule 32 (location -> ID .)
    OR              reduce using rule 32 (location -> ID .)
    SEMICOLON       reduce using rule 32 (location -> ID .)
    RBRACKET        reduce using rule 32 (location -> ID .)
    RPAREN          reduce using rule 32 (location -> ID .)
    COMMA           reduce using rule 32 (location -> ID .)
    LBRACKET        shift and go to state 34


state 66

    (21) block -> LBRACE decl_or_stmt_list . RBRACE
    (2) decl_or_stmt_list -> decl_or_stmt_list . decl_or_stmt
    (4) decl_or_stmt -> . var_decl
    (5) decl_or_stmt -> . func_decl
    (6) decl_or_stmt -> . statement
    (7) var_decl -> . type ID SEMICOLON
    (8) var_decl -> . type ID ASSIGN expr SEMICOLON
    (9) var_decl -> . type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON
    (15) func_decl -> . FUNC ID LPAREN param_list_opt RPAREN block
    (22) statement -> . assignment SEMICOLON
    (23) statement -> . if_stmt
    (24) statement -> . while_stmt
    (25) statement -> . for_stmt
    (26) statement -> . io_stmt SEMICOLON
    (27) statement -> . return_stmt SEMICOLON
    (28) statement -> . BREAK SEMICOLON
    (29) statement -> . CONTINUE SEMICOLON
    (30) statement -> . block
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . BOOL
    (13) type -> . CHAR
    (14) type -> . STRING
    (31) assignment -> . location ASSIGN expr
    (34) if_stmt -> . IF LPAREN expr RPAREN block elif_part else_part_opt
    (39) while_stmt -> . WHILE LPAREN expr RPAREN block
    (40) for_stmt -> . FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block
    (41) io_stmt -> . PRINT LPAREN expr RPAREN
    (42) io_stmt -> . INPUT LPAREN ID RPAREN
    (43) return_stmt -> . RETURN expr
    (44) return_stmt -> . RETURN
    (21) block -> . LBRACE decl_or_stmt_list RBRACE
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    RBRACE          shift and go to state 95
    FUNC            shift and go to state 9
    BREAK           shift and go to state 17
    CONTINUE        shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 21
    CHAR            shift and go to state 22
    STRING          shift and go to state 23
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    INPUT           shift and go to state 29
    RETURN          shift and go to state 30
    LBRACE          shift and go to state 31
    ID              shift and go to state 8

    decl_or_stmt                   shift and go to state 32
    var_decl                       shift and go to state 4
    func_decl                      shift and go to state 5
    statement                      shift and go to state 6
    type                           shift and go to state 7
    block                          shift and go to state 10
    assignment                     shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    for_stmt                       shift and go to state 14
    io_stmt                        shift and go to state 15
    return_stmt                    shift and go to state 16
    location                       shift and go to state 24

state 67

    (7) var_decl -> type ID SEMICOLON .

    FUNC            reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    BREAK           reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    CONTINUE        reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    INT             reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    FLOAT           reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    BOOL            reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    CHAR            reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    STRING          reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    IF              reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    WHILE           reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    FOR             reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    PRINT           reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    INPUT           reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    RETURN          reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    LBRACE          reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    ID              reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    $end            reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    RBRACE          reduce using rule 7 (var_decl -> type ID SEMICOLON .)


state 68

    (8) var_decl -> type ID ASSIGN . expr SEMICOLON
    (45) expr -> . logic_or_expr
    (46) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (47) logic_or_expr -> . logic_and_expr
    (48) logic_and_expr -> . logic_and_expr AND equality_expr
    (49) logic_and_expr -> . equality_expr
    (50) equality_expr -> . equality_expr EQ relational_expr
    (51) equality_expr -> . equality_expr NE relational_expr
    (52) equality_expr -> . relational_expr
    (53) relational_expr -> . relational_expr LT additive_expr
    (54) relational_expr -> . relational_expr LE additive_expr
    (55) relational_expr -> . relational_expr GT additive_expr
    (56) relational_expr -> . relational_expr GE additive_expr
    (57) relational_expr -> . additive_expr
    (58) additive_expr -> . additive_expr PLUS term
    (59) additive_expr -> . additive_expr MINUS term
    (60) additive_expr -> . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    expr                           shift and go to state 96
    logic_or_expr                  shift and go to state 48
    logic_and_expr                 shift and go to state 49
    equality_expr                  shift and go to state 50
    relational_expr                shift and go to state 51
    additive_expr                  shift and go to state 52
    term                           shift and go to state 53
    factor                         shift and go to state 55
    location                       shift and go to state 64

state 69

    (9) var_decl -> type ID LBRACKET . INT_LITERAL RBRACKET SEMICOLON

    INT_LITERAL     shift and go to state 97


state 70

    (33) location -> ID LBRACKET expr . RBRACKET

    RBRACKET        shift and go to state 98


state 71

    (15) func_decl -> FUNC ID LPAREN . param_list_opt RPAREN block
    (16) param_list_opt -> . param_list
    (17) param_list_opt -> . empty
    (18) param_list -> . param_list COMMA param
    (19) param_list -> . param
    (80) empty -> .
    (20) param -> . type ID
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . BOOL
    (13) type -> . CHAR
    (14) type -> . STRING

    RPAREN          reduce using rule 80 (empty -> .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 21
    CHAR            shift and go to state 22
    STRING          shift and go to state 23

    param_list_opt                 shift and go to state 99
    param_list                     shift and go to state 100
    empty                          shift and go to state 101
    param                          shift and go to state 102
    type                           shift and go to state 103

state 72

    (31) assignment -> location ASSIGN expr .

    SEMICOLON       reduce using rule 31 (assignment -> location ASSIGN expr .)
    RPAREN          reduce using rule 31 (assignment -> location ASSIGN expr .)


state 73

    (34) if_stmt -> IF LPAREN expr . RPAREN block elif_part else_part_opt

    RPAREN          shift and go to state 104


state 74

    (39) while_stmt -> WHILE LPAREN expr . RPAREN block

    RPAREN          shift and go to state 105


state 75

    (40) for_stmt -> FOR LPAREN assignment . SEMICOLON expr SEMICOLON assignment RPAREN block

    SEMICOLON       shift and go to state 106


state 76

    (41) io_stmt -> PRINT LPAREN expr . RPAREN

    RPAREN          shift and go to state 107


state 77

    (42) io_stmt -> INPUT LPAREN ID . RPAREN

    RPAREN          shift and go to state 108


state 78

    (46) logic_or_expr -> logic_or_expr OR . logic_and_expr
    (48) logic_and_expr -> . logic_and_expr AND equality_expr
    (49) logic_and_expr -> . equality_expr
    (50) equality_expr -> . equality_expr EQ relational_expr
    (51) equality_expr -> . equality_expr NE relational_expr
    (52) equality_expr -> . relational_expr
    (53) relational_expr -> . relational_expr LT additive_expr
    (54) relational_expr -> . relational_expr LE additive_expr
    (55) relational_expr -> . relational_expr GT additive_expr
    (56) relational_expr -> . relational_expr GE additive_expr
    (57) relational_expr -> . additive_expr
    (58) additive_expr -> . additive_expr PLUS term
    (59) additive_expr -> . additive_expr MINUS term
    (60) additive_expr -> . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    logic_and_expr                 shift and go to state 109
    equality_expr                  shift and go to state 50
    relational_expr                shift and go to state 51
    additive_expr                  shift and go to state 52
    term                           shift and go to state 53
    factor                         shift and go to state 55
    location                       shift and go to state 64

state 79

    (48) logic_and_expr -> logic_and_expr AND . equality_expr
    (50) equality_expr -> . equality_expr EQ relational_expr
    (51) equality_expr -> . equality_expr NE relational_expr
    (52) equality_expr -> . relational_expr
    (53) relational_expr -> . relational_expr LT additive_expr
    (54) relational_expr -> . relational_expr LE additive_expr
    (55) relational_expr -> . relational_expr GT additive_expr
    (56) relational_expr -> . relational_expr GE additive_expr
    (57) relational_expr -> . additive_expr
    (58) additive_expr -> . additive_expr PLUS term
    (59) additive_expr -> . additive_expr MINUS term
    (60) additive_expr -> . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    equality_expr                  shift and go to state 110
    relational_expr                shift and go to state 51
    additive_expr                  shift and go to state 52
    term                           shift and go to state 53
    factor                         shift and go to state 55
    location                       shift and go to state 64

state 80

    (50) equality_expr -> equality_expr EQ . relational_expr
    (53) relational_expr -> . relational_expr LT additive_expr
    (54) relational_expr -> . relational_expr LE additive_expr
    (55) relational_expr -> . relational_expr GT additive_expr
    (56) relational_expr -> . relational_expr GE additive_expr
    (57) relational_expr -> . additive_expr
    (58) additive_expr -> . additive_expr PLUS term
    (59) additive_expr -> . additive_expr MINUS term
    (60) additive_expr -> . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    relational_expr                shift and go to state 111
    additive_expr                  shift and go to state 52
    term                           shift and go to state 53
    factor                         shift and go to state 55
    location                       shift and go to state 64

state 81

    (51) equality_expr -> equality_expr NE . relational_expr
    (53) relational_expr -> . relational_expr LT additive_expr
    (54) relational_expr -> . relational_expr LE additive_expr
    (55) relational_expr -> . relational_expr GT additive_expr
    (56) relational_expr -> . relational_expr GE additive_expr
    (57) relational_expr -> . additive_expr
    (58) additive_expr -> . additive_expr PLUS term
    (59) additive_expr -> . additive_expr MINUS term
    (60) additive_expr -> . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    relational_expr                shift and go to state 112
    additive_expr                  shift and go to state 52
    term                           shift and go to state 53
    factor                         shift and go to state 55
    location                       shift and go to state 64

state 82

    (53) relational_expr -> relational_expr LT . additive_expr
    (58) additive_expr -> . additive_expr PLUS term
    (59) additive_expr -> . additive_expr MINUS term
    (60) additive_expr -> . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    additive_expr                  shift and go to state 113
    term                           shift and go to state 53
    factor                         shift and go to state 55
    location                       shift and go to state 64

state 83

    (54) relational_expr -> relational_expr LE . additive_expr
    (58) additive_expr -> . additive_expr PLUS term
    (59) additive_expr -> . additive_expr MINUS term
    (60) additive_expr -> . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    additive_expr                  shift and go to state 114
    term                           shift and go to state 53
    factor                         shift and go to state 55
    location                       shift and go to state 64

state 84

    (55) relational_expr -> relational_expr GT . additive_expr
    (58) additive_expr -> . additive_expr PLUS term
    (59) additive_expr -> . additive_expr MINUS term
    (60) additive_expr -> . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    additive_expr                  shift and go to state 115
    term                           shift and go to state 53
    factor                         shift and go to state 55
    location                       shift and go to state 64

state 85

    (56) relational_expr -> relational_expr GE . additive_expr
    (58) additive_expr -> . additive_expr PLUS term
    (59) additive_expr -> . additive_expr MINUS term
    (60) additive_expr -> . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    additive_expr                  shift and go to state 116
    term                           shift and go to state 53
    factor                         shift and go to state 55
    location                       shift and go to state 64

state 86

    (58) additive_expr -> additive_expr PLUS . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    term                           shift and go to state 117
    factor                         shift and go to state 55
    location                       shift and go to state 64

state 87

    (59) additive_expr -> additive_expr MINUS . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    term                           shift and go to state 118
    factor                         shift and go to state 55
    location                       shift and go to state 64

state 88

    (61) term -> term TIMES . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    factor                         shift and go to state 119
    location                       shift and go to state 64

state 89

    (62) term -> term DIVIDE . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    factor                         shift and go to state 120
    location                       shift and go to state 64

state 90

    (63) term -> term MOD . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    factor                         shift and go to state 121
    location                       shift and go to state 64

state 91

    (66) factor -> MINUS factor .

    TIMES           reduce using rule 66 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 66 (factor -> MINUS factor .)
    MOD             reduce using rule 66 (factor -> MINUS factor .)
    PLUS            reduce using rule 66 (factor -> MINUS factor .)
    MINUS           reduce using rule 66 (factor -> MINUS factor .)
    LT              reduce using rule 66 (factor -> MINUS factor .)
    LE              reduce using rule 66 (factor -> MINUS factor .)
    GT              reduce using rule 66 (factor -> MINUS factor .)
    GE              reduce using rule 66 (factor -> MINUS factor .)
    EQ              reduce using rule 66 (factor -> MINUS factor .)
    NE              reduce using rule 66 (factor -> MINUS factor .)
    AND             reduce using rule 66 (factor -> MINUS factor .)
    OR              reduce using rule 66 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 66 (factor -> MINUS factor .)
    RBRACKET        reduce using rule 66 (factor -> MINUS factor .)
    RPAREN          reduce using rule 66 (factor -> MINUS factor .)
    COMMA           reduce using rule 66 (factor -> MINUS factor .)


state 92

    (65) factor -> NOT factor .

    TIMES           reduce using rule 65 (factor -> NOT factor .)
    DIVIDE          reduce using rule 65 (factor -> NOT factor .)
    MOD             reduce using rule 65 (factor -> NOT factor .)
    PLUS            reduce using rule 65 (factor -> NOT factor .)
    MINUS           reduce using rule 65 (factor -> NOT factor .)
    LT              reduce using rule 65 (factor -> NOT factor .)
    LE              reduce using rule 65 (factor -> NOT factor .)
    GT              reduce using rule 65 (factor -> NOT factor .)
    GE              reduce using rule 65 (factor -> NOT factor .)
    EQ              reduce using rule 65 (factor -> NOT factor .)
    NE              reduce using rule 65 (factor -> NOT factor .)
    AND             reduce using rule 65 (factor -> NOT factor .)
    OR              reduce using rule 65 (factor -> NOT factor .)
    SEMICOLON       reduce using rule 65 (factor -> NOT factor .)
    RBRACKET        reduce using rule 65 (factor -> NOT factor .)
    RPAREN          reduce using rule 65 (factor -> NOT factor .)
    COMMA           reduce using rule 65 (factor -> NOT factor .)


state 93

    (67) factor -> LPAREN expr . RPAREN

    RPAREN          shift and go to state 122


state 94

    (75) factor -> ID LPAREN . arg_list_opt RPAREN
    (76) arg_list_opt -> . arg_list
    (77) arg_list_opt -> . empty
    (78) arg_list -> . arg_list COMMA expr
    (79) arg_list -> . expr
    (80) empty -> .
    (45) expr -> . logic_or_expr
    (46) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (47) logic_or_expr -> . logic_and_expr
    (48) logic_and_expr -> . logic_and_expr AND equality_expr
    (49) logic_and_expr -> . equality_expr
    (50) equality_expr -> . equality_expr EQ relational_expr
    (51) equality_expr -> . equality_expr NE relational_expr
    (52) equality_expr -> . relational_expr
    (53) relational_expr -> . relational_expr LT additive_expr
    (54) relational_expr -> . relational_expr LE additive_expr
    (55) relational_expr -> . relational_expr GT additive_expr
    (56) relational_expr -> . relational_expr GE additive_expr
    (57) relational_expr -> . additive_expr
    (58) additive_expr -> . additive_expr PLUS term
    (59) additive_expr -> . additive_expr MINUS term
    (60) additive_expr -> . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    RPAREN          reduce using rule 80 (empty -> .)
    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    arg_list_opt                   shift and go to state 123
    arg_list                       shift and go to state 124
    empty                          shift and go to state 125
    expr                           shift and go to state 126
    logic_or_expr                  shift and go to state 48
    logic_and_expr                 shift and go to state 49
    equality_expr                  shift and go to state 50
    relational_expr                shift and go to state 51
    additive_expr                  shift and go to state 52
    term                           shift and go to state 53
    factor                         shift and go to state 55
    location                       shift and go to state 64

state 95

    (21) block -> LBRACE decl_or_stmt_list RBRACE .

    FUNC            reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    BREAK           reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    CONTINUE        reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    INT             reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    FLOAT           reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    BOOL            reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    CHAR            reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    STRING          reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    IF              reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    WHILE           reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    FOR             reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    PRINT           reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    INPUT           reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    RETURN          reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    LBRACE          reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    ID              reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    $end            reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    RBRACE          reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    ELIF            reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    ELSE            reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)


state 96

    (8) var_decl -> type ID ASSIGN expr . SEMICOLON

    SEMICOLON       shift and go to state 127


state 97

    (9) var_decl -> type ID LBRACKET INT_LITERAL . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 128


state 98

    (33) location -> ID LBRACKET expr RBRACKET .

    ASSIGN          reduce using rule 33 (location -> ID LBRACKET expr RBRACKET .)
    TIMES           reduce using rule 33 (location -> ID LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 33 (location -> ID LBRACKET expr RBRACKET .)
    MOD             reduce using rule 33 (location -> ID LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 33 (location -> ID LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 33 (location -> ID LBRACKET expr RBRACKET .)
    LT              reduce using rule 33 (location -> ID LBRACKET expr RBRACKET .)
    LE              reduce using rule 33 (location -> ID LBRACKET expr RBRACKET .)
    GT              reduce using rule 33 (location -> ID LBRACKET expr RBRACKET .)
    GE              reduce using rule 33 (location -> ID LBRACKET expr RBRACKET .)
    EQ              reduce using rule 33 (location -> ID LBRACKET expr RBRACKET .)
    NE              reduce using rule 33 (location -> ID LBRACKET expr RBRACKET .)
    AND             reduce using rule 33 (location -> ID LBRACKET expr RBRACKET .)
    OR              reduce using rule 33 (location -> ID LBRACKET expr RBRACKET .)
    SEMICOLON       reduce using rule 33 (location -> ID LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 33 (location -> ID LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 33 (location -> ID LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 33 (location -> ID LBRACKET expr RBRACKET .)


state 99

    (15) func_decl -> FUNC ID LPAREN param_list_opt . RPAREN block

    RPAREN          shift and go to state 129


state 100

    (16) param_list_opt -> param_list .
    (18) param_list -> param_list . COMMA param

    RPAREN          reduce using rule 16 (param_list_opt -> param_list .)
    COMMA           shift and go to state 130


state 101

    (17) param_list_opt -> empty .

    RPAREN          reduce using rule 17 (param_list_opt -> empty .)


state 102

    (19) param_list -> param .

    COMMA           reduce using rule 19 (param_list -> param .)
    RPAREN          reduce using rule 19 (param_list -> param .)


state 103

    (20) param -> type . ID

    ID              shift and go to state 131


state 104

    (34) if_stmt -> IF LPAREN expr RPAREN . block elif_part else_part_opt
    (21) block -> . LBRACE decl_or_stmt_list RBRACE

    LBRACE          shift and go to state 31

    block                          shift and go to state 132

state 105

    (39) while_stmt -> WHILE LPAREN expr RPAREN . block
    (21) block -> . LBRACE decl_or_stmt_list RBRACE

    LBRACE          shift and go to state 31

    block                          shift and go to state 133

state 106

    (40) for_stmt -> FOR LPAREN assignment SEMICOLON . expr SEMICOLON assignment RPAREN block
    (45) expr -> . logic_or_expr
    (46) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (47) logic_or_expr -> . logic_and_expr
    (48) logic_and_expr -> . logic_and_expr AND equality_expr
    (49) logic_and_expr -> . equality_expr
    (50) equality_expr -> . equality_expr EQ relational_expr
    (51) equality_expr -> . equality_expr NE relational_expr
    (52) equality_expr -> . relational_expr
    (53) relational_expr -> . relational_expr LT additive_expr
    (54) relational_expr -> . relational_expr LE additive_expr
    (55) relational_expr -> . relational_expr GT additive_expr
    (56) relational_expr -> . relational_expr GE additive_expr
    (57) relational_expr -> . additive_expr
    (58) additive_expr -> . additive_expr PLUS term
    (59) additive_expr -> . additive_expr MINUS term
    (60) additive_expr -> . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    expr                           shift and go to state 134
    logic_or_expr                  shift and go to state 48
    logic_and_expr                 shift and go to state 49
    equality_expr                  shift and go to state 50
    relational_expr                shift and go to state 51
    additive_expr                  shift and go to state 52
    term                           shift and go to state 53
    factor                         shift and go to state 55
    location                       shift and go to state 64

state 107

    (41) io_stmt -> PRINT LPAREN expr RPAREN .

    SEMICOLON       reduce using rule 41 (io_stmt -> PRINT LPAREN expr RPAREN .)


state 108

    (42) io_stmt -> INPUT LPAREN ID RPAREN .

    SEMICOLON       reduce using rule 42 (io_stmt -> INPUT LPAREN ID RPAREN .)


state 109

    (46) logic_or_expr -> logic_or_expr OR logic_and_expr .
    (48) logic_and_expr -> logic_and_expr . AND equality_expr

    OR              reduce using rule 46 (logic_or_expr -> logic_or_expr OR logic_and_expr .)
    SEMICOLON       reduce using rule 46 (logic_or_expr -> logic_or_expr OR logic_and_expr .)
    RBRACKET        reduce using rule 46 (logic_or_expr -> logic_or_expr OR logic_and_expr .)
    RPAREN          reduce using rule 46 (logic_or_expr -> logic_or_expr OR logic_and_expr .)
    COMMA           reduce using rule 46 (logic_or_expr -> logic_or_expr OR logic_and_expr .)
    AND             shift and go to state 79


state 110

    (48) logic_and_expr -> logic_and_expr AND equality_expr .
    (50) equality_expr -> equality_expr . EQ relational_expr
    (51) equality_expr -> equality_expr . NE relational_expr

    AND             reduce using rule 48 (logic_and_expr -> logic_and_expr AND equality_expr .)
    OR              reduce using rule 48 (logic_and_expr -> logic_and_expr AND equality_expr .)
    SEMICOLON       reduce using rule 48 (logic_and_expr -> logic_and_expr AND equality_expr .)
    RBRACKET        reduce using rule 48 (logic_and_expr -> logic_and_expr AND equality_expr .)
    RPAREN          reduce using rule 48 (logic_and_expr -> logic_and_expr AND equality_expr .)
    COMMA           reduce using rule 48 (logic_and_expr -> logic_and_expr AND equality_expr .)
    EQ              shift and go to state 80
    NE              shift and go to state 81


state 111

    (50) equality_expr -> equality_expr EQ relational_expr .
    (53) relational_expr -> relational_expr . LT additive_expr
    (54) relational_expr -> relational_expr . LE additive_expr
    (55) relational_expr -> relational_expr . GT additive_expr
    (56) relational_expr -> relational_expr . GE additive_expr

    EQ              reduce using rule 50 (equality_expr -> equality_expr EQ relational_expr .)
    NE              reduce using rule 50 (equality_expr -> equality_expr EQ relational_expr .)
    AND             reduce using rule 50 (equality_expr -> equality_expr EQ relational_expr .)
    OR              reduce using rule 50 (equality_expr -> equality_expr EQ relational_expr .)
    SEMICOLON       reduce using rule 50 (equality_expr -> equality_expr EQ relational_expr .)
    RBRACKET        reduce using rule 50 (equality_expr -> equality_expr EQ relational_expr .)
    RPAREN          reduce using rule 50 (equality_expr -> equality_expr EQ relational_expr .)
    COMMA           reduce using rule 50 (equality_expr -> equality_expr EQ relational_expr .)
    LT              shift and go to state 82
    LE              shift and go to state 83
    GT              shift and go to state 84
    GE              shift and go to state 85


state 112

    (51) equality_expr -> equality_expr NE relational_expr .
    (53) relational_expr -> relational_expr . LT additive_expr
    (54) relational_expr -> relational_expr . LE additive_expr
    (55) relational_expr -> relational_expr . GT additive_expr
    (56) relational_expr -> relational_expr . GE additive_expr

    EQ              reduce using rule 51 (equality_expr -> equality_expr NE relational_expr .)
    NE              reduce using rule 51 (equality_expr -> equality_expr NE relational_expr .)
    AND             reduce using rule 51 (equality_expr -> equality_expr NE relational_expr .)
    OR              reduce using rule 51 (equality_expr -> equality_expr NE relational_expr .)
    SEMICOLON       reduce using rule 51 (equality_expr -> equality_expr NE relational_expr .)
    RBRACKET        reduce using rule 51 (equality_expr -> equality_expr NE relational_expr .)
    RPAREN          reduce using rule 51 (equality_expr -> equality_expr NE relational_expr .)
    COMMA           reduce using rule 51 (equality_expr -> equality_expr NE relational_expr .)
    LT              shift and go to state 82
    LE              shift and go to state 83
    GT              shift and go to state 84
    GE              shift and go to state 85


state 113

    (53) relational_expr -> relational_expr LT additive_expr .
    (58) additive_expr -> additive_expr . PLUS term
    (59) additive_expr -> additive_expr . MINUS term

    LT              reduce using rule 53 (relational_expr -> relational_expr LT additive_expr .)
    LE              reduce using rule 53 (relational_expr -> relational_expr LT additive_expr .)
    GT              reduce using rule 53 (relational_expr -> relational_expr LT additive_expr .)
    GE              reduce using rule 53 (relational_expr -> relational_expr LT additive_expr .)
    EQ              reduce using rule 53 (relational_expr -> relational_expr LT additive_expr .)
    NE              reduce using rule 53 (relational_expr -> relational_expr LT additive_expr .)
    AND             reduce using rule 53 (relational_expr -> relational_expr LT additive_expr .)
    OR              reduce using rule 53 (relational_expr -> relational_expr LT additive_expr .)
    SEMICOLON       reduce using rule 53 (relational_expr -> relational_expr LT additive_expr .)
    RBRACKET        reduce using rule 53 (relational_expr -> relational_expr LT additive_expr .)
    RPAREN          reduce using rule 53 (relational_expr -> relational_expr LT additive_expr .)
    COMMA           reduce using rule 53 (relational_expr -> relational_expr LT additive_expr .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 114

    (54) relational_expr -> relational_expr LE additive_expr .
    (58) additive_expr -> additive_expr . PLUS term
    (59) additive_expr -> additive_expr . MINUS term

    LT              reduce using rule 54 (relational_expr -> relational_expr LE additive_expr .)
    LE              reduce using rule 54 (relational_expr -> relational_expr LE additive_expr .)
    GT              reduce using rule 54 (relational_expr -> relational_expr LE additive_expr .)
    GE              reduce using rule 54 (relational_expr -> relational_expr LE additive_expr .)
    EQ              reduce using rule 54 (relational_expr -> relational_expr LE additive_expr .)
    NE              reduce using rule 54 (relational_expr -> relational_expr LE additive_expr .)
    AND             reduce using rule 54 (relational_expr -> relational_expr LE additive_expr .)
    OR              reduce using rule 54 (relational_expr -> relational_expr LE additive_expr .)
    SEMICOLON       reduce using rule 54 (relational_expr -> relational_expr LE additive_expr .)
    RBRACKET        reduce using rule 54 (relational_expr -> relational_expr LE additive_expr .)
    RPAREN          reduce using rule 54 (relational_expr -> relational_expr LE additive_expr .)
    COMMA           reduce using rule 54 (relational_expr -> relational_expr LE additive_expr .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 115

    (55) relational_expr -> relational_expr GT additive_expr .
    (58) additive_expr -> additive_expr . PLUS term
    (59) additive_expr -> additive_expr . MINUS term

    LT              reduce using rule 55 (relational_expr -> relational_expr GT additive_expr .)
    LE              reduce using rule 55 (relational_expr -> relational_expr GT additive_expr .)
    GT              reduce using rule 55 (relational_expr -> relational_expr GT additive_expr .)
    GE              reduce using rule 55 (relational_expr -> relational_expr GT additive_expr .)
    EQ              reduce using rule 55 (relational_expr -> relational_expr GT additive_expr .)
    NE              reduce using rule 55 (relational_expr -> relational_expr GT additive_expr .)
    AND             reduce using rule 55 (relational_expr -> relational_expr GT additive_expr .)
    OR              reduce using rule 55 (relational_expr -> relational_expr GT additive_expr .)
    SEMICOLON       reduce using rule 55 (relational_expr -> relational_expr GT additive_expr .)
    RBRACKET        reduce using rule 55 (relational_expr -> relational_expr GT additive_expr .)
    RPAREN          reduce using rule 55 (relational_expr -> relational_expr GT additive_expr .)
    COMMA           reduce using rule 55 (relational_expr -> relational_expr GT additive_expr .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 116

    (56) relational_expr -> relational_expr GE additive_expr .
    (58) additive_expr -> additive_expr . PLUS term
    (59) additive_expr -> additive_expr . MINUS term

    LT              reduce using rule 56 (relational_expr -> relational_expr GE additive_expr .)
    LE              reduce using rule 56 (relational_expr -> relational_expr GE additive_expr .)
    GT              reduce using rule 56 (relational_expr -> relational_expr GE additive_expr .)
    GE              reduce using rule 56 (relational_expr -> relational_expr GE additive_expr .)
    EQ              reduce using rule 56 (relational_expr -> relational_expr GE additive_expr .)
    NE              reduce using rule 56 (relational_expr -> relational_expr GE additive_expr .)
    AND             reduce using rule 56 (relational_expr -> relational_expr GE additive_expr .)
    OR              reduce using rule 56 (relational_expr -> relational_expr GE additive_expr .)
    SEMICOLON       reduce using rule 56 (relational_expr -> relational_expr GE additive_expr .)
    RBRACKET        reduce using rule 56 (relational_expr -> relational_expr GE additive_expr .)
    RPAREN          reduce using rule 56 (relational_expr -> relational_expr GE additive_expr .)
    COMMA           reduce using rule 56 (relational_expr -> relational_expr GE additive_expr .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 117

    (58) additive_expr -> additive_expr PLUS term .
    (61) term -> term . TIMES factor
    (62) term -> term . DIVIDE factor
    (63) term -> term . MOD factor

    PLUS            reduce using rule 58 (additive_expr -> additive_expr PLUS term .)
    MINUS           reduce using rule 58 (additive_expr -> additive_expr PLUS term .)
    LT              reduce using rule 58 (additive_expr -> additive_expr PLUS term .)
    LE              reduce using rule 58 (additive_expr -> additive_expr PLUS term .)
    GT              reduce using rule 58 (additive_expr -> additive_expr PLUS term .)
    GE              reduce using rule 58 (additive_expr -> additive_expr PLUS term .)
    EQ              reduce using rule 58 (additive_expr -> additive_expr PLUS term .)
    NE              reduce using rule 58 (additive_expr -> additive_expr PLUS term .)
    AND             reduce using rule 58 (additive_expr -> additive_expr PLUS term .)
    OR              reduce using rule 58 (additive_expr -> additive_expr PLUS term .)
    SEMICOLON       reduce using rule 58 (additive_expr -> additive_expr PLUS term .)
    RBRACKET        reduce using rule 58 (additive_expr -> additive_expr PLUS term .)
    RPAREN          reduce using rule 58 (additive_expr -> additive_expr PLUS term .)
    COMMA           reduce using rule 58 (additive_expr -> additive_expr PLUS term .)
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MOD             shift and go to state 90


state 118

    (59) additive_expr -> additive_expr MINUS term .
    (61) term -> term . TIMES factor
    (62) term -> term . DIVIDE factor
    (63) term -> term . MOD factor

    PLUS            reduce using rule 59 (additive_expr -> additive_expr MINUS term .)
    MINUS           reduce using rule 59 (additive_expr -> additive_expr MINUS term .)
    LT              reduce using rule 59 (additive_expr -> additive_expr MINUS term .)
    LE              reduce using rule 59 (additive_expr -> additive_expr MINUS term .)
    GT              reduce using rule 59 (additive_expr -> additive_expr MINUS term .)
    GE              reduce using rule 59 (additive_expr -> additive_expr MINUS term .)
    EQ              reduce using rule 59 (additive_expr -> additive_expr MINUS term .)
    NE              reduce using rule 59 (additive_expr -> additive_expr MINUS term .)
    AND             reduce using rule 59 (additive_expr -> additive_expr MINUS term .)
    OR              reduce using rule 59 (additive_expr -> additive_expr MINUS term .)
    SEMICOLON       reduce using rule 59 (additive_expr -> additive_expr MINUS term .)
    RBRACKET        reduce using rule 59 (additive_expr -> additive_expr MINUS term .)
    RPAREN          reduce using rule 59 (additive_expr -> additive_expr MINUS term .)
    COMMA           reduce using rule 59 (additive_expr -> additive_expr MINUS term .)
    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    MOD             shift and go to state 90


state 119

    (61) term -> term TIMES factor .

    TIMES           reduce using rule 61 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 61 (term -> term TIMES factor .)
    MOD             reduce using rule 61 (term -> term TIMES factor .)
    PLUS            reduce using rule 61 (term -> term TIMES factor .)
    MINUS           reduce using rule 61 (term -> term TIMES factor .)
    LT              reduce using rule 61 (term -> term TIMES factor .)
    LE              reduce using rule 61 (term -> term TIMES factor .)
    GT              reduce using rule 61 (term -> term TIMES factor .)
    GE              reduce using rule 61 (term -> term TIMES factor .)
    EQ              reduce using rule 61 (term -> term TIMES factor .)
    NE              reduce using rule 61 (term -> term TIMES factor .)
    AND             reduce using rule 61 (term -> term TIMES factor .)
    OR              reduce using rule 61 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 61 (term -> term TIMES factor .)
    RBRACKET        reduce using rule 61 (term -> term TIMES factor .)
    RPAREN          reduce using rule 61 (term -> term TIMES factor .)
    COMMA           reduce using rule 61 (term -> term TIMES factor .)


state 120

    (62) term -> term DIVIDE factor .

    TIMES           reduce using rule 62 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 62 (term -> term DIVIDE factor .)
    MOD             reduce using rule 62 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 62 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 62 (term -> term DIVIDE factor .)
    LT              reduce using rule 62 (term -> term DIVIDE factor .)
    LE              reduce using rule 62 (term -> term DIVIDE factor .)
    GT              reduce using rule 62 (term -> term DIVIDE factor .)
    GE              reduce using rule 62 (term -> term DIVIDE factor .)
    EQ              reduce using rule 62 (term -> term DIVIDE factor .)
    NE              reduce using rule 62 (term -> term DIVIDE factor .)
    AND             reduce using rule 62 (term -> term DIVIDE factor .)
    OR              reduce using rule 62 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 62 (term -> term DIVIDE factor .)
    RBRACKET        reduce using rule 62 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 62 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 62 (term -> term DIVIDE factor .)


state 121

    (63) term -> term MOD factor .

    TIMES           reduce using rule 63 (term -> term MOD factor .)
    DIVIDE          reduce using rule 63 (term -> term MOD factor .)
    MOD             reduce using rule 63 (term -> term MOD factor .)
    PLUS            reduce using rule 63 (term -> term MOD factor .)
    MINUS           reduce using rule 63 (term -> term MOD factor .)
    LT              reduce using rule 63 (term -> term MOD factor .)
    LE              reduce using rule 63 (term -> term MOD factor .)
    GT              reduce using rule 63 (term -> term MOD factor .)
    GE              reduce using rule 63 (term -> term MOD factor .)
    EQ              reduce using rule 63 (term -> term MOD factor .)
    NE              reduce using rule 63 (term -> term MOD factor .)
    AND             reduce using rule 63 (term -> term MOD factor .)
    OR              reduce using rule 63 (term -> term MOD factor .)
    SEMICOLON       reduce using rule 63 (term -> term MOD factor .)
    RBRACKET        reduce using rule 63 (term -> term MOD factor .)
    RPAREN          reduce using rule 63 (term -> term MOD factor .)
    COMMA           reduce using rule 63 (term -> term MOD factor .)


state 122

    (67) factor -> LPAREN expr RPAREN .

    TIMES           reduce using rule 67 (factor -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 67 (factor -> LPAREN expr RPAREN .)
    MOD             reduce using rule 67 (factor -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 67 (factor -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 67 (factor -> LPAREN expr RPAREN .)
    LT              reduce using rule 67 (factor -> LPAREN expr RPAREN .)
    LE              reduce using rule 67 (factor -> LPAREN expr RPAREN .)
    GT              reduce using rule 67 (factor -> LPAREN expr RPAREN .)
    GE              reduce using rule 67 (factor -> LPAREN expr RPAREN .)
    EQ              reduce using rule 67 (factor -> LPAREN expr RPAREN .)
    NE              reduce using rule 67 (factor -> LPAREN expr RPAREN .)
    AND             reduce using rule 67 (factor -> LPAREN expr RPAREN .)
    OR              reduce using rule 67 (factor -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 67 (factor -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 67 (factor -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 67 (factor -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 67 (factor -> LPAREN expr RPAREN .)


state 123

    (75) factor -> ID LPAREN arg_list_opt . RPAREN

    RPAREN          shift and go to state 135


state 124

    (76) arg_list_opt -> arg_list .
    (78) arg_list -> arg_list . COMMA expr

    RPAREN          reduce using rule 76 (arg_list_opt -> arg_list .)
    COMMA           shift and go to state 136


state 125

    (77) arg_list_opt -> empty .

    RPAREN          reduce using rule 77 (arg_list_opt -> empty .)


state 126

    (79) arg_list -> expr .

    COMMA           reduce using rule 79 (arg_list -> expr .)
    RPAREN          reduce using rule 79 (arg_list -> expr .)


state 127

    (8) var_decl -> type ID ASSIGN expr SEMICOLON .

    FUNC            reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    BREAK           reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    CONTINUE        reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    INT             reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    FLOAT           reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    BOOL            reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    CHAR            reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    STRING          reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    IF              reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    PRINT           reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    INPUT           reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    LBRACE          reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    RBRACE          reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)


state 128

    (9) var_decl -> type ID LBRACKET INT_LITERAL RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 137


state 129

    (15) func_decl -> FUNC ID LPAREN param_list_opt RPAREN . block
    (21) block -> . LBRACE decl_or_stmt_list RBRACE

    LBRACE          shift and go to state 31

    block                          shift and go to state 138

state 130

    (18) param_list -> param_list COMMA . param
    (20) param -> . type ID
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . BOOL
    (13) type -> . CHAR
    (14) type -> . STRING

    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    BOOL            shift and go to state 21
    CHAR            shift and go to state 22
    STRING          shift and go to state 23

    param                          shift and go to state 139
    type                           shift and go to state 103

state 131

    (20) param -> type ID .

    COMMA           reduce using rule 20 (param -> type ID .)
    RPAREN          reduce using rule 20 (param -> type ID .)


state 132

    (34) if_stmt -> IF LPAREN expr RPAREN block . elif_part else_part_opt
    (35) elif_part -> . ELIF LPAREN expr RPAREN block elif_part
    (36) elif_part -> . empty
    (80) empty -> .

    ELIF            shift and go to state 141
    ELSE            reduce using rule 80 (empty -> .)
    FUNC            reduce using rule 80 (empty -> .)
    BREAK           reduce using rule 80 (empty -> .)
    CONTINUE        reduce using rule 80 (empty -> .)
    INT             reduce using rule 80 (empty -> .)
    FLOAT           reduce using rule 80 (empty -> .)
    BOOL            reduce using rule 80 (empty -> .)
    CHAR            reduce using rule 80 (empty -> .)
    STRING          reduce using rule 80 (empty -> .)
    IF              reduce using rule 80 (empty -> .)
    WHILE           reduce using rule 80 (empty -> .)
    FOR             reduce using rule 80 (empty -> .)
    PRINT           reduce using rule 80 (empty -> .)
    INPUT           reduce using rule 80 (empty -> .)
    RETURN          reduce using rule 80 (empty -> .)
    LBRACE          reduce using rule 80 (empty -> .)
    ID              reduce using rule 80 (empty -> .)
    $end            reduce using rule 80 (empty -> .)
    RBRACE          reduce using rule 80 (empty -> .)

    elif_part                      shift and go to state 140
    empty                          shift and go to state 142

state 133

    (39) while_stmt -> WHILE LPAREN expr RPAREN block .

    FUNC            reduce using rule 39 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    BREAK           reduce using rule 39 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    CONTINUE        reduce using rule 39 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    INT             reduce using rule 39 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    FLOAT           reduce using rule 39 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    BOOL            reduce using rule 39 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    CHAR            reduce using rule 39 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    STRING          reduce using rule 39 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    IF              reduce using rule 39 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    WHILE           reduce using rule 39 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    FOR             reduce using rule 39 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    PRINT           reduce using rule 39 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    INPUT           reduce using rule 39 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    RETURN          reduce using rule 39 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    LBRACE          reduce using rule 39 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    ID              reduce using rule 39 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    $end            reduce using rule 39 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    RBRACE          reduce using rule 39 (while_stmt -> WHILE LPAREN expr RPAREN block .)


state 134

    (40) for_stmt -> FOR LPAREN assignment SEMICOLON expr . SEMICOLON assignment RPAREN block

    SEMICOLON       shift and go to state 143


state 135

    (75) factor -> ID LPAREN arg_list_opt RPAREN .

    TIMES           reduce using rule 75 (factor -> ID LPAREN arg_list_opt RPAREN .)
    DIVIDE          reduce using rule 75 (factor -> ID LPAREN arg_list_opt RPAREN .)
    MOD             reduce using rule 75 (factor -> ID LPAREN arg_list_opt RPAREN .)
    PLUS            reduce using rule 75 (factor -> ID LPAREN arg_list_opt RPAREN .)
    MINUS           reduce using rule 75 (factor -> ID LPAREN arg_list_opt RPAREN .)
    LT              reduce using rule 75 (factor -> ID LPAREN arg_list_opt RPAREN .)
    LE              reduce using rule 75 (factor -> ID LPAREN arg_list_opt RPAREN .)
    GT              reduce using rule 75 (factor -> ID LPAREN arg_list_opt RPAREN .)
    GE              reduce using rule 75 (factor -> ID LPAREN arg_list_opt RPAREN .)
    EQ              reduce using rule 75 (factor -> ID LPAREN arg_list_opt RPAREN .)
    NE              reduce using rule 75 (factor -> ID LPAREN arg_list_opt RPAREN .)
    AND             reduce using rule 75 (factor -> ID LPAREN arg_list_opt RPAREN .)
    OR              reduce using rule 75 (factor -> ID LPAREN arg_list_opt RPAREN .)
    SEMICOLON       reduce using rule 75 (factor -> ID LPAREN arg_list_opt RPAREN .)
    RBRACKET        reduce using rule 75 (factor -> ID LPAREN arg_list_opt RPAREN .)
    RPAREN          reduce using rule 75 (factor -> ID LPAREN arg_list_opt RPAREN .)
    COMMA           reduce using rule 75 (factor -> ID LPAREN arg_list_opt RPAREN .)


state 136

    (78) arg_list -> arg_list COMMA . expr
    (45) expr -> . logic_or_expr
    (46) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (47) logic_or_expr -> . logic_and_expr
    (48) logic_and_expr -> . logic_and_expr AND equality_expr
    (49) logic_and_expr -> . equality_expr
    (50) equality_expr -> . equality_expr EQ relational_expr
    (51) equality_expr -> . equality_expr NE relational_expr
    (52) equality_expr -> . relational_expr
    (53) relational_expr -> . relational_expr LT additive_expr
    (54) relational_expr -> . relational_expr LE additive_expr
    (55) relational_expr -> . relational_expr GT additive_expr
    (56) relational_expr -> . relational_expr GE additive_expr
    (57) relational_expr -> . additive_expr
    (58) additive_expr -> . additive_expr PLUS term
    (59) additive_expr -> . additive_expr MINUS term
    (60) additive_expr -> . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    expr                           shift and go to state 144
    logic_or_expr                  shift and go to state 48
    logic_and_expr                 shift and go to state 49
    equality_expr                  shift and go to state 50
    relational_expr                shift and go to state 51
    additive_expr                  shift and go to state 52
    term                           shift and go to state 53
    factor                         shift and go to state 55
    location                       shift and go to state 64

state 137

    (9) var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .

    FUNC            reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    BREAK           reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    CONTINUE        reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    INT             reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    FLOAT           reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    BOOL            reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    CHAR            reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    STRING          reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    IF              reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    WHILE           reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    FOR             reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    PRINT           reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    INPUT           reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    RETURN          reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    LBRACE          reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    ID              reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    $end            reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)


state 138

    (15) func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .

    FUNC            reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    BREAK           reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    CONTINUE        reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    INT             reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    FLOAT           reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    BOOL            reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    CHAR            reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    STRING          reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    IF              reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    WHILE           reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    FOR             reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    PRINT           reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    INPUT           reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    RETURN          reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    LBRACE          reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    ID              reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    $end            reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    RBRACE          reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)


state 139

    (18) param_list -> param_list COMMA param .

    COMMA           reduce using rule 18 (param_list -> param_list COMMA param .)
    RPAREN          reduce using rule 18 (param_list -> param_list COMMA param .)


state 140

    (34) if_stmt -> IF LPAREN expr RPAREN block elif_part . else_part_opt
    (37) else_part_opt -> . ELSE block
    (38) else_part_opt -> . empty
    (80) empty -> .

    ELSE            shift and go to state 146
    FUNC            reduce using rule 80 (empty -> .)
    BREAK           reduce using rule 80 (empty -> .)
    CONTINUE        reduce using rule 80 (empty -> .)
    INT             reduce using rule 80 (empty -> .)
    FLOAT           reduce using rule 80 (empty -> .)
    BOOL            reduce using rule 80 (empty -> .)
    CHAR            reduce using rule 80 (empty -> .)
    STRING          reduce using rule 80 (empty -> .)
    IF              reduce using rule 80 (empty -> .)
    WHILE           reduce using rule 80 (empty -> .)
    FOR             reduce using rule 80 (empty -> .)
    PRINT           reduce using rule 80 (empty -> .)
    INPUT           reduce using rule 80 (empty -> .)
    RETURN          reduce using rule 80 (empty -> .)
    LBRACE          reduce using rule 80 (empty -> .)
    ID              reduce using rule 80 (empty -> .)
    $end            reduce using rule 80 (empty -> .)
    RBRACE          reduce using rule 80 (empty -> .)

    else_part_opt                  shift and go to state 145
    empty                          shift and go to state 147

state 141

    (35) elif_part -> ELIF . LPAREN expr RPAREN block elif_part

    LPAREN          shift and go to state 148


state 142

    (36) elif_part -> empty .

    ELSE            reduce using rule 36 (elif_part -> empty .)
    FUNC            reduce using rule 36 (elif_part -> empty .)
    BREAK           reduce using rule 36 (elif_part -> empty .)
    CONTINUE        reduce using rule 36 (elif_part -> empty .)
    INT             reduce using rule 36 (elif_part -> empty .)
    FLOAT           reduce using rule 36 (elif_part -> empty .)
    BOOL            reduce using rule 36 (elif_part -> empty .)
    CHAR            reduce using rule 36 (elif_part -> empty .)
    STRING          reduce using rule 36 (elif_part -> empty .)
    IF              reduce using rule 36 (elif_part -> empty .)
    WHILE           reduce using rule 36 (elif_part -> empty .)
    FOR             reduce using rule 36 (elif_part -> empty .)
    PRINT           reduce using rule 36 (elif_part -> empty .)
    INPUT           reduce using rule 36 (elif_part -> empty .)
    RETURN          reduce using rule 36 (elif_part -> empty .)
    LBRACE          reduce using rule 36 (elif_part -> empty .)
    ID              reduce using rule 36 (elif_part -> empty .)
    $end            reduce using rule 36 (elif_part -> empty .)
    RBRACE          reduce using rule 36 (elif_part -> empty .)


state 143

    (40) for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON . assignment RPAREN block
    (31) assignment -> . location ASSIGN expr
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    ID              shift and go to state 8

    assignment                     shift and go to state 149
    location                       shift and go to state 24

state 144

    (78) arg_list -> arg_list COMMA expr .

    COMMA           reduce using rule 78 (arg_list -> arg_list COMMA expr .)
    RPAREN          reduce using rule 78 (arg_list -> arg_list COMMA expr .)


state 145

    (34) if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .

    FUNC            reduce using rule 34 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    BREAK           reduce using rule 34 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    CONTINUE        reduce using rule 34 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    INT             reduce using rule 34 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    FLOAT           reduce using rule 34 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    BOOL            reduce using rule 34 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    CHAR            reduce using rule 34 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    STRING          reduce using rule 34 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    IF              reduce using rule 34 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    WHILE           reduce using rule 34 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    FOR             reduce using rule 34 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    PRINT           reduce using rule 34 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    INPUT           reduce using rule 34 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    RETURN          reduce using rule 34 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    LBRACE          reduce using rule 34 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    ID              reduce using rule 34 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    $end            reduce using rule 34 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    RBRACE          reduce using rule 34 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)


state 146

    (37) else_part_opt -> ELSE . block
    (21) block -> . LBRACE decl_or_stmt_list RBRACE

    LBRACE          shift and go to state 31

    block                          shift and go to state 150

state 147

    (38) else_part_opt -> empty .

    FUNC            reduce using rule 38 (else_part_opt -> empty .)
    BREAK           reduce using rule 38 (else_part_opt -> empty .)
    CONTINUE        reduce using rule 38 (else_part_opt -> empty .)
    INT             reduce using rule 38 (else_part_opt -> empty .)
    FLOAT           reduce using rule 38 (else_part_opt -> empty .)
    BOOL            reduce using rule 38 (else_part_opt -> empty .)
    CHAR            reduce using rule 38 (else_part_opt -> empty .)
    STRING          reduce using rule 38 (else_part_opt -> empty .)
    IF              reduce using rule 38 (else_part_opt -> empty .)
    WHILE           reduce using rule 38 (else_part_opt -> empty .)
    FOR             reduce using rule 38 (else_part_opt -> empty .)
    PRINT           reduce using rule 38 (else_part_opt -> empty .)
    INPUT           reduce using rule 38 (else_part_opt -> empty .)
    RETURN          reduce using rule 38 (else_part_opt -> empty .)
    LBRACE          reduce using rule 38 (else_part_opt -> empty .)
    ID              reduce using rule 38 (else_part_opt -> empty .)
    $end            reduce using rule 38 (else_part_opt -> empty .)
    RBRACE          reduce using rule 38 (else_part_opt -> empty .)


state 148

    (35) elif_part -> ELIF LPAREN . expr RPAREN block elif_part
    (45) expr -> . logic_or_expr
    (46) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (47) logic_or_expr -> . logic_and_expr
    (48) logic_and_expr -> . logic_and_expr AND equality_expr
    (49) logic_and_expr -> . equality_expr
    (50) equality_expr -> . equality_expr EQ relational_expr
    (51) equality_expr -> . equality_expr NE relational_expr
    (52) equality_expr -> . relational_expr
    (53) relational_expr -> . relational_expr LT additive_expr
    (54) relational_expr -> . relational_expr LE additive_expr
    (55) relational_expr -> . relational_expr GT additive_expr
    (56) relational_expr -> . relational_expr GE additive_expr
    (57) relational_expr -> . additive_expr
    (58) additive_expr -> . additive_expr PLUS term
    (59) additive_expr -> . additive_expr MINUS term
    (60) additive_expr -> . term
    (61) term -> . term TIMES factor
    (62) term -> . term DIVIDE factor
    (63) term -> . term MOD factor
    (64) term -> . factor
    (65) factor -> . NOT factor
    (66) factor -> . MINUS factor
    (67) factor -> . LPAREN expr RPAREN
    (68) factor -> . INT_LITERAL
    (69) factor -> . FLOAT_LITERAL
    (70) factor -> . TRUE
    (71) factor -> . FALSE
    (72) factor -> . CHAR_LITERAL
    (73) factor -> . STRING_LITERAL
    (74) factor -> . location
    (75) factor -> . ID LPAREN arg_list_opt RPAREN
    (32) location -> . ID
    (33) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 56
    MINUS           shift and go to state 54
    LPAREN          shift and go to state 57
    INT_LITERAL     shift and go to state 58
    FLOAT_LITERAL   shift and go to state 59
    TRUE            shift and go to state 60
    FALSE           shift and go to state 61
    CHAR_LITERAL    shift and go to state 62
    STRING_LITERAL  shift and go to state 63
    ID              shift and go to state 65

    expr                           shift and go to state 151
    logic_or_expr                  shift and go to state 48
    logic_and_expr                 shift and go to state 49
    equality_expr                  shift and go to state 50
    relational_expr                shift and go to state 51
    additive_expr                  shift and go to state 52
    term                           shift and go to state 53
    factor                         shift and go to state 55
    location                       shift and go to state 64

state 149

    (40) for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment . RPAREN block

    RPAREN          shift and go to state 152


state 150

    (37) else_part_opt -> ELSE block .

    FUNC            reduce using rule 37 (else_part_opt -> ELSE block .)
    BREAK           reduce using rule 37 (else_part_opt -> ELSE block .)
    CONTINUE        reduce using rule 37 (else_part_opt -> ELSE block .)
    INT             reduce using rule 37 (else_part_opt -> ELSE block .)
    FLOAT           reduce using rule 37 (else_part_opt -> ELSE block .)
    BOOL            reduce using rule 37 (else_part_opt -> ELSE block .)
    CHAR            reduce using rule 37 (else_part_opt -> ELSE block .)
    STRING          reduce using rule 37 (else_part_opt -> ELSE block .)
    IF              reduce using rule 37 (else_part_opt -> ELSE block .)
    WHILE           reduce using rule 37 (else_part_opt -> ELSE block .)
    FOR             reduce using rule 37 (else_part_opt -> ELSE block .)
    PRINT           reduce using rule 37 (else_part_opt -> ELSE block .)
    INPUT           reduce using rule 37 (else_part_opt -> ELSE block .)
    RETURN          reduce using rule 37 (else_part_opt -> ELSE block .)
    LBRACE          reduce using rule 37 (else_part_opt -> ELSE block .)
    ID              reduce using rule 37 (else_part_opt -> ELSE block .)
    $end            reduce using rule 37 (else_part_opt -> ELSE block .)
    RBRACE          reduce using rule 37 (else_part_opt -> ELSE block .)


state 151

    (35) elif_part -> ELIF LPAREN expr . RPAREN block elif_part

    RPAREN          shift and go to state 153


state 152

    (40) for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN . block
    (21) block -> . LBRACE decl_or_stmt_list RBRACE

    LBRACE          shift and go to state 31

    block                          shift and go to state 154

state 153

    (35) elif_part -> ELIF LPAREN expr RPAREN . block elif_part
    (21) block -> . LBRACE decl_or_stmt_list RBRACE

    LBRACE          shift and go to state 31

    block                          shift and go to state 155

state 154

    (40) for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .

    FUNC            reduce using rule 40 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    BREAK           reduce using rule 40 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    CONTINUE        reduce using rule 40 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    INT             reduce using rule 40 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    FLOAT           reduce using rule 40 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    BOOL            reduce using rule 40 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    CHAR            reduce using rule 40 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    STRING          reduce using rule 40 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    IF              reduce using rule 40 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    WHILE           reduce using rule 40 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    FOR             reduce using rule 40 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    PRINT           reduce using rule 40 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    INPUT           reduce using rule 40 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    RETURN          reduce using rule 40 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    LBRACE          reduce using rule 40 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    ID              reduce using rule 40 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    $end            reduce using rule 40 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    RBRACE          reduce using rule 40 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)


state 155

    (35) elif_part -> ELIF LPAREN expr RPAREN block . elif_part
    (35) elif_part -> . ELIF LPAREN expr RPAREN block elif_part
    (36) elif_part -> . empty
    (80) empty -> .

    ELIF            shift and go to state 141
    ELSE            reduce using rule 80 (empty -> .)
    FUNC            reduce using rule 80 (empty -> .)
    BREAK           reduce using rule 80 (empty -> .)
    CONTINUE        reduce using rule 80 (empty -> .)
    INT             reduce using rule 80 (empty -> .)
    FLOAT           reduce using rule 80 (empty -> .)
    BOOL            reduce using rule 80 (empty -> .)
    CHAR            reduce using rule 80 (empty -> .)
    STRING          reduce using rule 80 (empty -> .)
    IF              reduce using rule 80 (empty -> .)
    WHILE           reduce using rule 80 (empty -> .)
    FOR             reduce using rule 80 (empty -> .)
    PRINT           reduce using rule 80 (empty -> .)
    INPUT           reduce using rule 80 (empty -> .)
    RETURN          reduce using rule 80 (empty -> .)
    LBRACE          reduce using rule 80 (empty -> .)
    ID              reduce using rule 80 (empty -> .)
    $end            reduce using rule 80 (empty -> .)
    RBRACE          reduce using rule 80 (empty -> .)

    elif_part                      shift and go to state 156
    empty                          shift and go to state 142

state 156

    (35) elif_part -> ELIF LPAREN expr RPAREN block elif_part .

    ELSE            reduce using rule 35 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    FUNC            reduce using rule 35 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    BREAK           reduce using rule 35 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    CONTINUE        reduce using rule 35 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    INT             reduce using rule 35 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    FLOAT           reduce using rule 35 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    BOOL            reduce using rule 35 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    CHAR            reduce using rule 35 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    STRING          reduce using rule 35 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    IF              reduce using rule 35 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    WHILE           reduce using rule 35 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    FOR             reduce using rule 35 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    PRINT           reduce using rule 35 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    INPUT           reduce using rule 35 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    RETURN          reduce using rule 35 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    LBRACE          reduce using rule 35 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    ID              reduce using rule 35 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    $end            reduce using rule 35 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    RBRACE          reduce using rule 35 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)

