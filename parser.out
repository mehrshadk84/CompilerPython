Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> decl_or_stmt_list
Rule 2     decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt
Rule 3     decl_or_stmt_list -> decl_or_stmt
Rule 4     decl_or_stmt -> var_decl
Rule 5     decl_or_stmt -> func_decl
Rule 6     decl_or_stmt -> statement
Rule 7     var_decl -> type ID SEMICOLON
Rule 8     var_decl -> type ID ASSIGN expr SEMICOLON
Rule 9     var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON
Rule 10    type -> INT
Rule 11    type -> FLOAT
Rule 12    type -> BOOL
Rule 13    type -> CHAR
Rule 14    type -> STRING
Rule 15    func_decl -> FUNC ID LPAREN param_list_opt RPAREN block
Rule 16    param_list_opt -> param_list
Rule 17    param_list_opt -> empty
Rule 18    param_list -> param_list COMMA param
Rule 19    param_list -> param
Rule 20    param -> type ID
Rule 21    block -> LBRACE decl_or_stmt_list RBRACE
Rule 22    statement -> assignment SEMICOLON
Rule 23    statement -> if_stmt
Rule 24    statement -> while_stmt
Rule 25    statement -> for_stmt
Rule 26    statement -> io_stmt SEMICOLON
Rule 27    statement -> return_stmt SEMICOLON
Rule 28    statement -> BREAK SEMICOLON
Rule 29    statement -> CONTINUE SEMICOLON
Rule 30    statement -> block
Rule 31    statement -> func_call SEMICOLON
Rule 32    func_call -> ID LPAREN arg_list_opt RPAREN
Rule 33    assignment -> location ASSIGN expr
Rule 34    location -> ID
Rule 35    location -> ID LBRACKET expr RBRACKET
Rule 36    if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt
Rule 37    elif_part -> ELIF LPAREN expr RPAREN block elif_part
Rule 38    elif_part -> empty
Rule 39    else_part_opt -> ELSE block
Rule 40    else_part_opt -> empty
Rule 41    while_stmt -> WHILE LPAREN expr RPAREN block
Rule 42    for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block
Rule 43    io_stmt -> PRINT LPAREN expr RPAREN
Rule 44    io_stmt -> INPUT LPAREN ID RPAREN
Rule 45    return_stmt -> RETURN expr
Rule 46    return_stmt -> RETURN
Rule 47    expr -> logic_or_expr
Rule 48    logic_or_expr -> logic_or_expr OR logic_and_expr
Rule 49    logic_or_expr -> logic_and_expr
Rule 50    logic_and_expr -> logic_and_expr AND equality_expr
Rule 51    logic_and_expr -> equality_expr
Rule 52    equality_expr -> equality_expr EQ relational_expr
Rule 53    equality_expr -> equality_expr NE relational_expr
Rule 54    equality_expr -> relational_expr
Rule 55    relational_expr -> relational_expr LT additive_expr
Rule 56    relational_expr -> relational_expr LE additive_expr
Rule 57    relational_expr -> relational_expr GT additive_expr
Rule 58    relational_expr -> relational_expr GE additive_expr
Rule 59    relational_expr -> additive_expr
Rule 60    additive_expr -> additive_expr PLUS term
Rule 61    additive_expr -> additive_expr MINUS term
Rule 62    additive_expr -> term
Rule 63    term -> term TIMES factor
Rule 64    term -> term DIVIDE factor
Rule 65    term -> term MOD factor
Rule 66    term -> factor
Rule 67    factor -> NOT factor
Rule 68    factor -> MINUS factor
Rule 69    factor -> LPAREN expr RPAREN
Rule 70    factor -> INT_LITERAL
Rule 71    factor -> FLOAT_LITERAL
Rule 72    factor -> TRUE
Rule 73    factor -> FALSE
Rule 74    factor -> CHAR_LITERAL
Rule 75    factor -> STRING_LITERAL
Rule 76    factor -> location
Rule 77    factor -> ID LPAREN arg_list_opt RPAREN
Rule 78    arg_list_opt -> arg_list
Rule 79    arg_list_opt -> empty
Rule 80    arg_list -> arg_list COMMA expr
Rule 81    arg_list -> expr
Rule 82    empty -> <empty>

Terminals, with rules where they appear

AND                  : 50
ASSIGN               : 8 33
BOOL                 : 12
BREAK                : 28
CHAR                 : 13
CHAR_LITERAL         : 74
COMMA                : 18 80
CONTINUE             : 29
DIVIDE               : 64
ELIF                 : 37
ELSE                 : 39
EQ                   : 52
FALSE                : 73
FLOAT                : 11
FLOAT_LITERAL        : 71
FOR                  : 42
FUNC                 : 15
GE                   : 58
GT                   : 57
ID                   : 7 8 9 15 20 32 34 35 44 77
IF                   : 36
INPUT                : 44
INT                  : 10
INT_LITERAL          : 9 70
LBRACE               : 21
LBRACKET             : 9 35
LE                   : 56
LPAREN               : 15 32 36 37 41 42 43 44 69 77
LT                   : 55
MINUS                : 61 68
MOD                  : 65
NE                   : 53
NOT                  : 67
OR                   : 48
PLUS                 : 60
PRINT                : 43
RBRACE               : 21
RBRACKET             : 9 35
RETURN               : 45 46
RPAREN               : 15 32 36 37 41 42 43 44 69 77
SEMICOLON            : 7 8 9 22 26 27 28 29 31 42 42
STRING               : 14
STRING_LITERAL       : 75
TIMES                : 63
TRUE                 : 72
WHILE                : 41
error                : 

Nonterminals, with rules where they appear

additive_expr        : 55 56 57 58 59 60 61
arg_list             : 78 80
arg_list_opt         : 32 77
assignment           : 22 42 42
block                : 15 30 36 37 39 41 42
decl_or_stmt         : 2 3
decl_or_stmt_list    : 1 2 21
elif_part            : 36 37
else_part_opt        : 36
empty                : 17 38 40 79
equality_expr        : 50 51 52 53
expr                 : 8 33 35 36 37 41 42 43 45 69 80 81
factor               : 63 64 65 66 67 68
for_stmt             : 25
func_call            : 31
func_decl            : 5
if_stmt              : 23
io_stmt              : 26
location             : 33 76
logic_and_expr       : 48 49 50
logic_or_expr        : 47 48
param                : 18 19
param_list           : 16 18
param_list_opt       : 15
program              : 0
relational_expr      : 52 53 54 55 56 57 58
return_stmt          : 27
statement            : 6
term                 : 60 61 62 63 64 65
type                 : 7 8 9 20
var_decl             : 4
while_stmt           : 24

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . decl_or_stmt_list
    (2) decl_or_stmt_list -> . decl_or_stmt_list decl_or_stmt
    (3) decl_or_stmt_list -> . decl_or_stmt
    (4) decl_or_stmt -> . var_decl
    (5) decl_or_stmt -> . func_decl
    (6) decl_or_stmt -> . statement
    (7) var_decl -> . type ID SEMICOLON
    (8) var_decl -> . type ID ASSIGN expr SEMICOLON
    (9) var_decl -> . type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON
    (15) func_decl -> . FUNC ID LPAREN param_list_opt RPAREN block
    (22) statement -> . assignment SEMICOLON
    (23) statement -> . if_stmt
    (24) statement -> . while_stmt
    (25) statement -> . for_stmt
    (26) statement -> . io_stmt SEMICOLON
    (27) statement -> . return_stmt SEMICOLON
    (28) statement -> . BREAK SEMICOLON
    (29) statement -> . CONTINUE SEMICOLON
    (30) statement -> . block
    (31) statement -> . func_call SEMICOLON
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . BOOL
    (13) type -> . CHAR
    (14) type -> . STRING
    (33) assignment -> . location ASSIGN expr
    (36) if_stmt -> . IF LPAREN expr RPAREN block elif_part else_part_opt
    (41) while_stmt -> . WHILE LPAREN expr RPAREN block
    (42) for_stmt -> . FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block
    (43) io_stmt -> . PRINT LPAREN expr RPAREN
    (44) io_stmt -> . INPUT LPAREN ID RPAREN
    (45) return_stmt -> . RETURN expr
    (46) return_stmt -> . RETURN
    (21) block -> . LBRACE decl_or_stmt_list RBRACE
    (32) func_call -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    FUNC            shift and go to state 9
    BREAK           shift and go to state 17
    CONTINUE        shift and go to state 18
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    BOOL            shift and go to state 22
    CHAR            shift and go to state 23
    STRING          shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    PRINT           shift and go to state 29
    INPUT           shift and go to state 30
    RETURN          shift and go to state 31
    LBRACE          shift and go to state 32
    ID              shift and go to state 8

    program                        shift and go to state 1
    decl_or_stmt_list              shift and go to state 2
    decl_or_stmt                   shift and go to state 3
    var_decl                       shift and go to state 4
    func_decl                      shift and go to state 5
    statement                      shift and go to state 6
    type                           shift and go to state 7
    block                          shift and go to state 10
    assignment                     shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    for_stmt                       shift and go to state 14
    io_stmt                        shift and go to state 15
    return_stmt                    shift and go to state 16
    func_call                      shift and go to state 19
    location                       shift and go to state 25

state 1

    (0) S' -> program .



state 2

    (1) program -> decl_or_stmt_list .
    (2) decl_or_stmt_list -> decl_or_stmt_list . decl_or_stmt
    (4) decl_or_stmt -> . var_decl
    (5) decl_or_stmt -> . func_decl
    (6) decl_or_stmt -> . statement
    (7) var_decl -> . type ID SEMICOLON
    (8) var_decl -> . type ID ASSIGN expr SEMICOLON
    (9) var_decl -> . type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON
    (15) func_decl -> . FUNC ID LPAREN param_list_opt RPAREN block
    (22) statement -> . assignment SEMICOLON
    (23) statement -> . if_stmt
    (24) statement -> . while_stmt
    (25) statement -> . for_stmt
    (26) statement -> . io_stmt SEMICOLON
    (27) statement -> . return_stmt SEMICOLON
    (28) statement -> . BREAK SEMICOLON
    (29) statement -> . CONTINUE SEMICOLON
    (30) statement -> . block
    (31) statement -> . func_call SEMICOLON
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . BOOL
    (13) type -> . CHAR
    (14) type -> . STRING
    (33) assignment -> . location ASSIGN expr
    (36) if_stmt -> . IF LPAREN expr RPAREN block elif_part else_part_opt
    (41) while_stmt -> . WHILE LPAREN expr RPAREN block
    (42) for_stmt -> . FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block
    (43) io_stmt -> . PRINT LPAREN expr RPAREN
    (44) io_stmt -> . INPUT LPAREN ID RPAREN
    (45) return_stmt -> . RETURN expr
    (46) return_stmt -> . RETURN
    (21) block -> . LBRACE decl_or_stmt_list RBRACE
    (32) func_call -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    $end            reduce using rule 1 (program -> decl_or_stmt_list .)
    FUNC            shift and go to state 9
    BREAK           shift and go to state 17
    CONTINUE        shift and go to state 18
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    BOOL            shift and go to state 22
    CHAR            shift and go to state 23
    STRING          shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    PRINT           shift and go to state 29
    INPUT           shift and go to state 30
    RETURN          shift and go to state 31
    LBRACE          shift and go to state 32
    ID              shift and go to state 8

    decl_or_stmt                   shift and go to state 33
    var_decl                       shift and go to state 4
    func_decl                      shift and go to state 5
    statement                      shift and go to state 6
    type                           shift and go to state 7
    block                          shift and go to state 10
    assignment                     shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    for_stmt                       shift and go to state 14
    io_stmt                        shift and go to state 15
    return_stmt                    shift and go to state 16
    func_call                      shift and go to state 19
    location                       shift and go to state 25

state 3

    (3) decl_or_stmt_list -> decl_or_stmt .

    FUNC            reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    BREAK           reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    CONTINUE        reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    INT             reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    FLOAT           reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    BOOL            reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    CHAR            reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    STRING          reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    IF              reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    WHILE           reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    FOR             reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    PRINT           reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    INPUT           reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    RETURN          reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    LBRACE          reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    ID              reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    $end            reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)
    RBRACE          reduce using rule 3 (decl_or_stmt_list -> decl_or_stmt .)


state 4

    (4) decl_or_stmt -> var_decl .

    FUNC            reduce using rule 4 (decl_or_stmt -> var_decl .)
    BREAK           reduce using rule 4 (decl_or_stmt -> var_decl .)
    CONTINUE        reduce using rule 4 (decl_or_stmt -> var_decl .)
    INT             reduce using rule 4 (decl_or_stmt -> var_decl .)
    FLOAT           reduce using rule 4 (decl_or_stmt -> var_decl .)
    BOOL            reduce using rule 4 (decl_or_stmt -> var_decl .)
    CHAR            reduce using rule 4 (decl_or_stmt -> var_decl .)
    STRING          reduce using rule 4 (decl_or_stmt -> var_decl .)
    IF              reduce using rule 4 (decl_or_stmt -> var_decl .)
    WHILE           reduce using rule 4 (decl_or_stmt -> var_decl .)
    FOR             reduce using rule 4 (decl_or_stmt -> var_decl .)
    PRINT           reduce using rule 4 (decl_or_stmt -> var_decl .)
    INPUT           reduce using rule 4 (decl_or_stmt -> var_decl .)
    RETURN          reduce using rule 4 (decl_or_stmt -> var_decl .)
    LBRACE          reduce using rule 4 (decl_or_stmt -> var_decl .)
    ID              reduce using rule 4 (decl_or_stmt -> var_decl .)
    $end            reduce using rule 4 (decl_or_stmt -> var_decl .)
    RBRACE          reduce using rule 4 (decl_or_stmt -> var_decl .)


state 5

    (5) decl_or_stmt -> func_decl .

    FUNC            reduce using rule 5 (decl_or_stmt -> func_decl .)
    BREAK           reduce using rule 5 (decl_or_stmt -> func_decl .)
    CONTINUE        reduce using rule 5 (decl_or_stmt -> func_decl .)
    INT             reduce using rule 5 (decl_or_stmt -> func_decl .)
    FLOAT           reduce using rule 5 (decl_or_stmt -> func_decl .)
    BOOL            reduce using rule 5 (decl_or_stmt -> func_decl .)
    CHAR            reduce using rule 5 (decl_or_stmt -> func_decl .)
    STRING          reduce using rule 5 (decl_or_stmt -> func_decl .)
    IF              reduce using rule 5 (decl_or_stmt -> func_decl .)
    WHILE           reduce using rule 5 (decl_or_stmt -> func_decl .)
    FOR             reduce using rule 5 (decl_or_stmt -> func_decl .)
    PRINT           reduce using rule 5 (decl_or_stmt -> func_decl .)
    INPUT           reduce using rule 5 (decl_or_stmt -> func_decl .)
    RETURN          reduce using rule 5 (decl_or_stmt -> func_decl .)
    LBRACE          reduce using rule 5 (decl_or_stmt -> func_decl .)
    ID              reduce using rule 5 (decl_or_stmt -> func_decl .)
    $end            reduce using rule 5 (decl_or_stmt -> func_decl .)
    RBRACE          reduce using rule 5 (decl_or_stmt -> func_decl .)


state 6

    (6) decl_or_stmt -> statement .

    FUNC            reduce using rule 6 (decl_or_stmt -> statement .)
    BREAK           reduce using rule 6 (decl_or_stmt -> statement .)
    CONTINUE        reduce using rule 6 (decl_or_stmt -> statement .)
    INT             reduce using rule 6 (decl_or_stmt -> statement .)
    FLOAT           reduce using rule 6 (decl_or_stmt -> statement .)
    BOOL            reduce using rule 6 (decl_or_stmt -> statement .)
    CHAR            reduce using rule 6 (decl_or_stmt -> statement .)
    STRING          reduce using rule 6 (decl_or_stmt -> statement .)
    IF              reduce using rule 6 (decl_or_stmt -> statement .)
    WHILE           reduce using rule 6 (decl_or_stmt -> statement .)
    FOR             reduce using rule 6 (decl_or_stmt -> statement .)
    PRINT           reduce using rule 6 (decl_or_stmt -> statement .)
    INPUT           reduce using rule 6 (decl_or_stmt -> statement .)
    RETURN          reduce using rule 6 (decl_or_stmt -> statement .)
    LBRACE          reduce using rule 6 (decl_or_stmt -> statement .)
    ID              reduce using rule 6 (decl_or_stmt -> statement .)
    $end            reduce using rule 6 (decl_or_stmt -> statement .)
    RBRACE          reduce using rule 6 (decl_or_stmt -> statement .)


state 7

    (7) var_decl -> type . ID SEMICOLON
    (8) var_decl -> type . ID ASSIGN expr SEMICOLON
    (9) var_decl -> type . ID LBRACKET INT_LITERAL RBRACKET SEMICOLON

    ID              shift and go to state 34


state 8

    (32) func_call -> ID . LPAREN arg_list_opt RPAREN
    (34) location -> ID .
    (35) location -> ID . LBRACKET expr RBRACKET

    LPAREN          shift and go to state 35
    ASSIGN          reduce using rule 34 (location -> ID .)
    LBRACKET        shift and go to state 36


state 9

    (15) func_decl -> FUNC . ID LPAREN param_list_opt RPAREN block

    ID              shift and go to state 37


state 10

    (30) statement -> block .

    FUNC            reduce using rule 30 (statement -> block .)
    BREAK           reduce using rule 30 (statement -> block .)
    CONTINUE        reduce using rule 30 (statement -> block .)
    INT             reduce using rule 30 (statement -> block .)
    FLOAT           reduce using rule 30 (statement -> block .)
    BOOL            reduce using rule 30 (statement -> block .)
    CHAR            reduce using rule 30 (statement -> block .)
    STRING          reduce using rule 30 (statement -> block .)
    IF              reduce using rule 30 (statement -> block .)
    WHILE           reduce using rule 30 (statement -> block .)
    FOR             reduce using rule 30 (statement -> block .)
    PRINT           reduce using rule 30 (statement -> block .)
    INPUT           reduce using rule 30 (statement -> block .)
    RETURN          reduce using rule 30 (statement -> block .)
    LBRACE          reduce using rule 30 (statement -> block .)
    ID              reduce using rule 30 (statement -> block .)
    $end            reduce using rule 30 (statement -> block .)
    RBRACE          reduce using rule 30 (statement -> block .)


state 11

    (22) statement -> assignment . SEMICOLON

    SEMICOLON       shift and go to state 38


state 12

    (23) statement -> if_stmt .

    FUNC            reduce using rule 23 (statement -> if_stmt .)
    BREAK           reduce using rule 23 (statement -> if_stmt .)
    CONTINUE        reduce using rule 23 (statement -> if_stmt .)
    INT             reduce using rule 23 (statement -> if_stmt .)
    FLOAT           reduce using rule 23 (statement -> if_stmt .)
    BOOL            reduce using rule 23 (statement -> if_stmt .)
    CHAR            reduce using rule 23 (statement -> if_stmt .)
    STRING          reduce using rule 23 (statement -> if_stmt .)
    IF              reduce using rule 23 (statement -> if_stmt .)
    WHILE           reduce using rule 23 (statement -> if_stmt .)
    FOR             reduce using rule 23 (statement -> if_stmt .)
    PRINT           reduce using rule 23 (statement -> if_stmt .)
    INPUT           reduce using rule 23 (statement -> if_stmt .)
    RETURN          reduce using rule 23 (statement -> if_stmt .)
    LBRACE          reduce using rule 23 (statement -> if_stmt .)
    ID              reduce using rule 23 (statement -> if_stmt .)
    $end            reduce using rule 23 (statement -> if_stmt .)
    RBRACE          reduce using rule 23 (statement -> if_stmt .)


state 13

    (24) statement -> while_stmt .

    FUNC            reduce using rule 24 (statement -> while_stmt .)
    BREAK           reduce using rule 24 (statement -> while_stmt .)
    CONTINUE        reduce using rule 24 (statement -> while_stmt .)
    INT             reduce using rule 24 (statement -> while_stmt .)
    FLOAT           reduce using rule 24 (statement -> while_stmt .)
    BOOL            reduce using rule 24 (statement -> while_stmt .)
    CHAR            reduce using rule 24 (statement -> while_stmt .)
    STRING          reduce using rule 24 (statement -> while_stmt .)
    IF              reduce using rule 24 (statement -> while_stmt .)
    WHILE           reduce using rule 24 (statement -> while_stmt .)
    FOR             reduce using rule 24 (statement -> while_stmt .)
    PRINT           reduce using rule 24 (statement -> while_stmt .)
    INPUT           reduce using rule 24 (statement -> while_stmt .)
    RETURN          reduce using rule 24 (statement -> while_stmt .)
    LBRACE          reduce using rule 24 (statement -> while_stmt .)
    ID              reduce using rule 24 (statement -> while_stmt .)
    $end            reduce using rule 24 (statement -> while_stmt .)
    RBRACE          reduce using rule 24 (statement -> while_stmt .)


state 14

    (25) statement -> for_stmt .

    FUNC            reduce using rule 25 (statement -> for_stmt .)
    BREAK           reduce using rule 25 (statement -> for_stmt .)
    CONTINUE        reduce using rule 25 (statement -> for_stmt .)
    INT             reduce using rule 25 (statement -> for_stmt .)
    FLOAT           reduce using rule 25 (statement -> for_stmt .)
    BOOL            reduce using rule 25 (statement -> for_stmt .)
    CHAR            reduce using rule 25 (statement -> for_stmt .)
    STRING          reduce using rule 25 (statement -> for_stmt .)
    IF              reduce using rule 25 (statement -> for_stmt .)
    WHILE           reduce using rule 25 (statement -> for_stmt .)
    FOR             reduce using rule 25 (statement -> for_stmt .)
    PRINT           reduce using rule 25 (statement -> for_stmt .)
    INPUT           reduce using rule 25 (statement -> for_stmt .)
    RETURN          reduce using rule 25 (statement -> for_stmt .)
    LBRACE          reduce using rule 25 (statement -> for_stmt .)
    ID              reduce using rule 25 (statement -> for_stmt .)
    $end            reduce using rule 25 (statement -> for_stmt .)
    RBRACE          reduce using rule 25 (statement -> for_stmt .)


state 15

    (26) statement -> io_stmt . SEMICOLON

    SEMICOLON       shift and go to state 39


state 16

    (27) statement -> return_stmt . SEMICOLON

    SEMICOLON       shift and go to state 40


state 17

    (28) statement -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 41


state 18

    (29) statement -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 42


state 19

    (31) statement -> func_call . SEMICOLON

    SEMICOLON       shift and go to state 43


state 20

    (10) type -> INT .

    ID              reduce using rule 10 (type -> INT .)


state 21

    (11) type -> FLOAT .

    ID              reduce using rule 11 (type -> FLOAT .)


state 22

    (12) type -> BOOL .

    ID              reduce using rule 12 (type -> BOOL .)


state 23

    (13) type -> CHAR .

    ID              reduce using rule 13 (type -> CHAR .)


state 24

    (14) type -> STRING .

    ID              reduce using rule 14 (type -> STRING .)


state 25

    (33) assignment -> location . ASSIGN expr

    ASSIGN          shift and go to state 44


state 26

    (36) if_stmt -> IF . LPAREN expr RPAREN block elif_part else_part_opt

    LPAREN          shift and go to state 45


state 27

    (41) while_stmt -> WHILE . LPAREN expr RPAREN block

    LPAREN          shift and go to state 46


state 28

    (42) for_stmt -> FOR . LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block

    LPAREN          shift and go to state 47


state 29

    (43) io_stmt -> PRINT . LPAREN expr RPAREN

    LPAREN          shift and go to state 48


state 30

    (44) io_stmt -> INPUT . LPAREN ID RPAREN

    LPAREN          shift and go to state 49


state 31

    (45) return_stmt -> RETURN . expr
    (46) return_stmt -> RETURN .
    (47) expr -> . logic_or_expr
    (48) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (49) logic_or_expr -> . logic_and_expr
    (50) logic_and_expr -> . logic_and_expr AND equality_expr
    (51) logic_and_expr -> . equality_expr
    (52) equality_expr -> . equality_expr EQ relational_expr
    (53) equality_expr -> . equality_expr NE relational_expr
    (54) equality_expr -> . relational_expr
    (55) relational_expr -> . relational_expr LT additive_expr
    (56) relational_expr -> . relational_expr LE additive_expr
    (57) relational_expr -> . relational_expr GT additive_expr
    (58) relational_expr -> . relational_expr GE additive_expr
    (59) relational_expr -> . additive_expr
    (60) additive_expr -> . additive_expr PLUS term
    (61) additive_expr -> . additive_expr MINUS term
    (62) additive_expr -> . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    SEMICOLON       reduce using rule 46 (return_stmt -> RETURN .)
    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    expr                           shift and go to state 50
    logic_or_expr                  shift and go to state 51
    logic_and_expr                 shift and go to state 52
    equality_expr                  shift and go to state 53
    relational_expr                shift and go to state 54
    additive_expr                  shift and go to state 55
    term                           shift and go to state 56
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 32

    (21) block -> LBRACE . decl_or_stmt_list RBRACE
    (2) decl_or_stmt_list -> . decl_or_stmt_list decl_or_stmt
    (3) decl_or_stmt_list -> . decl_or_stmt
    (4) decl_or_stmt -> . var_decl
    (5) decl_or_stmt -> . func_decl
    (6) decl_or_stmt -> . statement
    (7) var_decl -> . type ID SEMICOLON
    (8) var_decl -> . type ID ASSIGN expr SEMICOLON
    (9) var_decl -> . type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON
    (15) func_decl -> . FUNC ID LPAREN param_list_opt RPAREN block
    (22) statement -> . assignment SEMICOLON
    (23) statement -> . if_stmt
    (24) statement -> . while_stmt
    (25) statement -> . for_stmt
    (26) statement -> . io_stmt SEMICOLON
    (27) statement -> . return_stmt SEMICOLON
    (28) statement -> . BREAK SEMICOLON
    (29) statement -> . CONTINUE SEMICOLON
    (30) statement -> . block
    (31) statement -> . func_call SEMICOLON
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . BOOL
    (13) type -> . CHAR
    (14) type -> . STRING
    (33) assignment -> . location ASSIGN expr
    (36) if_stmt -> . IF LPAREN expr RPAREN block elif_part else_part_opt
    (41) while_stmt -> . WHILE LPAREN expr RPAREN block
    (42) for_stmt -> . FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block
    (43) io_stmt -> . PRINT LPAREN expr RPAREN
    (44) io_stmt -> . INPUT LPAREN ID RPAREN
    (45) return_stmt -> . RETURN expr
    (46) return_stmt -> . RETURN
    (21) block -> . LBRACE decl_or_stmt_list RBRACE
    (32) func_call -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    FUNC            shift and go to state 9
    BREAK           shift and go to state 17
    CONTINUE        shift and go to state 18
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    BOOL            shift and go to state 22
    CHAR            shift and go to state 23
    STRING          shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    PRINT           shift and go to state 29
    INPUT           shift and go to state 30
    RETURN          shift and go to state 31
    LBRACE          shift and go to state 32
    ID              shift and go to state 8

    decl_or_stmt_list              shift and go to state 69
    decl_or_stmt                   shift and go to state 3
    var_decl                       shift and go to state 4
    func_decl                      shift and go to state 5
    statement                      shift and go to state 6
    type                           shift and go to state 7
    block                          shift and go to state 10
    assignment                     shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    for_stmt                       shift and go to state 14
    io_stmt                        shift and go to state 15
    return_stmt                    shift and go to state 16
    func_call                      shift and go to state 19
    location                       shift and go to state 25

state 33

    (2) decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .

    FUNC            reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    BREAK           reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    CONTINUE        reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    INT             reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    FLOAT           reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    BOOL            reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    CHAR            reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    STRING          reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    IF              reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    WHILE           reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    FOR             reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    PRINT           reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    INPUT           reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    RETURN          reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    LBRACE          reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    ID              reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    $end            reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)
    RBRACE          reduce using rule 2 (decl_or_stmt_list -> decl_or_stmt_list decl_or_stmt .)


state 34

    (7) var_decl -> type ID . SEMICOLON
    (8) var_decl -> type ID . ASSIGN expr SEMICOLON
    (9) var_decl -> type ID . LBRACKET INT_LITERAL RBRACKET SEMICOLON

    SEMICOLON       shift and go to state 70
    ASSIGN          shift and go to state 71
    LBRACKET        shift and go to state 72


state 35

    (32) func_call -> ID LPAREN . arg_list_opt RPAREN
    (78) arg_list_opt -> . arg_list
    (79) arg_list_opt -> . empty
    (80) arg_list -> . arg_list COMMA expr
    (81) arg_list -> . expr
    (82) empty -> .
    (47) expr -> . logic_or_expr
    (48) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (49) logic_or_expr -> . logic_and_expr
    (50) logic_and_expr -> . logic_and_expr AND equality_expr
    (51) logic_and_expr -> . equality_expr
    (52) equality_expr -> . equality_expr EQ relational_expr
    (53) equality_expr -> . equality_expr NE relational_expr
    (54) equality_expr -> . relational_expr
    (55) relational_expr -> . relational_expr LT additive_expr
    (56) relational_expr -> . relational_expr LE additive_expr
    (57) relational_expr -> . relational_expr GT additive_expr
    (58) relational_expr -> . relational_expr GE additive_expr
    (59) relational_expr -> . additive_expr
    (60) additive_expr -> . additive_expr PLUS term
    (61) additive_expr -> . additive_expr MINUS term
    (62) additive_expr -> . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    RPAREN          reduce using rule 82 (empty -> .)
    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    arg_list_opt                   shift and go to state 73
    arg_list                       shift and go to state 74
    empty                          shift and go to state 75
    expr                           shift and go to state 76
    logic_or_expr                  shift and go to state 51
    logic_and_expr                 shift and go to state 52
    equality_expr                  shift and go to state 53
    relational_expr                shift and go to state 54
    additive_expr                  shift and go to state 55
    term                           shift and go to state 56
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 36

    (35) location -> ID LBRACKET . expr RBRACKET
    (47) expr -> . logic_or_expr
    (48) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (49) logic_or_expr -> . logic_and_expr
    (50) logic_and_expr -> . logic_and_expr AND equality_expr
    (51) logic_and_expr -> . equality_expr
    (52) equality_expr -> . equality_expr EQ relational_expr
    (53) equality_expr -> . equality_expr NE relational_expr
    (54) equality_expr -> . relational_expr
    (55) relational_expr -> . relational_expr LT additive_expr
    (56) relational_expr -> . relational_expr LE additive_expr
    (57) relational_expr -> . relational_expr GT additive_expr
    (58) relational_expr -> . relational_expr GE additive_expr
    (59) relational_expr -> . additive_expr
    (60) additive_expr -> . additive_expr PLUS term
    (61) additive_expr -> . additive_expr MINUS term
    (62) additive_expr -> . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    expr                           shift and go to state 77
    logic_or_expr                  shift and go to state 51
    logic_and_expr                 shift and go to state 52
    equality_expr                  shift and go to state 53
    relational_expr                shift and go to state 54
    additive_expr                  shift and go to state 55
    term                           shift and go to state 56
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 37

    (15) func_decl -> FUNC ID . LPAREN param_list_opt RPAREN block

    LPAREN          shift and go to state 78


state 38

    (22) statement -> assignment SEMICOLON .

    FUNC            reduce using rule 22 (statement -> assignment SEMICOLON .)
    BREAK           reduce using rule 22 (statement -> assignment SEMICOLON .)
    CONTINUE        reduce using rule 22 (statement -> assignment SEMICOLON .)
    INT             reduce using rule 22 (statement -> assignment SEMICOLON .)
    FLOAT           reduce using rule 22 (statement -> assignment SEMICOLON .)
    BOOL            reduce using rule 22 (statement -> assignment SEMICOLON .)
    CHAR            reduce using rule 22 (statement -> assignment SEMICOLON .)
    STRING          reduce using rule 22 (statement -> assignment SEMICOLON .)
    IF              reduce using rule 22 (statement -> assignment SEMICOLON .)
    WHILE           reduce using rule 22 (statement -> assignment SEMICOLON .)
    FOR             reduce using rule 22 (statement -> assignment SEMICOLON .)
    PRINT           reduce using rule 22 (statement -> assignment SEMICOLON .)
    INPUT           reduce using rule 22 (statement -> assignment SEMICOLON .)
    RETURN          reduce using rule 22 (statement -> assignment SEMICOLON .)
    LBRACE          reduce using rule 22 (statement -> assignment SEMICOLON .)
    ID              reduce using rule 22 (statement -> assignment SEMICOLON .)
    $end            reduce using rule 22 (statement -> assignment SEMICOLON .)
    RBRACE          reduce using rule 22 (statement -> assignment SEMICOLON .)


state 39

    (26) statement -> io_stmt SEMICOLON .

    FUNC            reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    BREAK           reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    CONTINUE        reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    INT             reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    FLOAT           reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    BOOL            reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    CHAR            reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    STRING          reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    IF              reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    WHILE           reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    FOR             reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    PRINT           reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    INPUT           reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    RETURN          reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    LBRACE          reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    ID              reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    $end            reduce using rule 26 (statement -> io_stmt SEMICOLON .)
    RBRACE          reduce using rule 26 (statement -> io_stmt SEMICOLON .)


state 40

    (27) statement -> return_stmt SEMICOLON .

    FUNC            reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    BREAK           reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    CONTINUE        reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    INT             reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    FLOAT           reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    BOOL            reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    CHAR            reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    STRING          reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    IF              reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    WHILE           reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    FOR             reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    PRINT           reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    INPUT           reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    RETURN          reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    LBRACE          reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    ID              reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    $end            reduce using rule 27 (statement -> return_stmt SEMICOLON .)
    RBRACE          reduce using rule 27 (statement -> return_stmt SEMICOLON .)


state 41

    (28) statement -> BREAK SEMICOLON .

    FUNC            reduce using rule 28 (statement -> BREAK SEMICOLON .)
    BREAK           reduce using rule 28 (statement -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 28 (statement -> BREAK SEMICOLON .)
    INT             reduce using rule 28 (statement -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 28 (statement -> BREAK SEMICOLON .)
    BOOL            reduce using rule 28 (statement -> BREAK SEMICOLON .)
    CHAR            reduce using rule 28 (statement -> BREAK SEMICOLON .)
    STRING          reduce using rule 28 (statement -> BREAK SEMICOLON .)
    IF              reduce using rule 28 (statement -> BREAK SEMICOLON .)
    WHILE           reduce using rule 28 (statement -> BREAK SEMICOLON .)
    FOR             reduce using rule 28 (statement -> BREAK SEMICOLON .)
    PRINT           reduce using rule 28 (statement -> BREAK SEMICOLON .)
    INPUT           reduce using rule 28 (statement -> BREAK SEMICOLON .)
    RETURN          reduce using rule 28 (statement -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 28 (statement -> BREAK SEMICOLON .)
    ID              reduce using rule 28 (statement -> BREAK SEMICOLON .)
    $end            reduce using rule 28 (statement -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 28 (statement -> BREAK SEMICOLON .)


state 42

    (29) statement -> CONTINUE SEMICOLON .

    FUNC            reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    INT             reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    BOOL            reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    CHAR            reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    STRING          reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    IF              reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    PRINT           reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    INPUT           reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    LBRACE          reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    ID              reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    $end            reduce using rule 29 (statement -> CONTINUE SEMICOLON .)
    RBRACE          reduce using rule 29 (statement -> CONTINUE SEMICOLON .)


state 43

    (31) statement -> func_call SEMICOLON .

    FUNC            reduce using rule 31 (statement -> func_call SEMICOLON .)
    BREAK           reduce using rule 31 (statement -> func_call SEMICOLON .)
    CONTINUE        reduce using rule 31 (statement -> func_call SEMICOLON .)
    INT             reduce using rule 31 (statement -> func_call SEMICOLON .)
    FLOAT           reduce using rule 31 (statement -> func_call SEMICOLON .)
    BOOL            reduce using rule 31 (statement -> func_call SEMICOLON .)
    CHAR            reduce using rule 31 (statement -> func_call SEMICOLON .)
    STRING          reduce using rule 31 (statement -> func_call SEMICOLON .)
    IF              reduce using rule 31 (statement -> func_call SEMICOLON .)
    WHILE           reduce using rule 31 (statement -> func_call SEMICOLON .)
    FOR             reduce using rule 31 (statement -> func_call SEMICOLON .)
    PRINT           reduce using rule 31 (statement -> func_call SEMICOLON .)
    INPUT           reduce using rule 31 (statement -> func_call SEMICOLON .)
    RETURN          reduce using rule 31 (statement -> func_call SEMICOLON .)
    LBRACE          reduce using rule 31 (statement -> func_call SEMICOLON .)
    ID              reduce using rule 31 (statement -> func_call SEMICOLON .)
    $end            reduce using rule 31 (statement -> func_call SEMICOLON .)
    RBRACE          reduce using rule 31 (statement -> func_call SEMICOLON .)


state 44

    (33) assignment -> location ASSIGN . expr
    (47) expr -> . logic_or_expr
    (48) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (49) logic_or_expr -> . logic_and_expr
    (50) logic_and_expr -> . logic_and_expr AND equality_expr
    (51) logic_and_expr -> . equality_expr
    (52) equality_expr -> . equality_expr EQ relational_expr
    (53) equality_expr -> . equality_expr NE relational_expr
    (54) equality_expr -> . relational_expr
    (55) relational_expr -> . relational_expr LT additive_expr
    (56) relational_expr -> . relational_expr LE additive_expr
    (57) relational_expr -> . relational_expr GT additive_expr
    (58) relational_expr -> . relational_expr GE additive_expr
    (59) relational_expr -> . additive_expr
    (60) additive_expr -> . additive_expr PLUS term
    (61) additive_expr -> . additive_expr MINUS term
    (62) additive_expr -> . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    location                       shift and go to state 67
    expr                           shift and go to state 79
    logic_or_expr                  shift and go to state 51
    logic_and_expr                 shift and go to state 52
    equality_expr                  shift and go to state 53
    relational_expr                shift and go to state 54
    additive_expr                  shift and go to state 55
    term                           shift and go to state 56
    factor                         shift and go to state 58

state 45

    (36) if_stmt -> IF LPAREN . expr RPAREN block elif_part else_part_opt
    (47) expr -> . logic_or_expr
    (48) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (49) logic_or_expr -> . logic_and_expr
    (50) logic_and_expr -> . logic_and_expr AND equality_expr
    (51) logic_and_expr -> . equality_expr
    (52) equality_expr -> . equality_expr EQ relational_expr
    (53) equality_expr -> . equality_expr NE relational_expr
    (54) equality_expr -> . relational_expr
    (55) relational_expr -> . relational_expr LT additive_expr
    (56) relational_expr -> . relational_expr LE additive_expr
    (57) relational_expr -> . relational_expr GT additive_expr
    (58) relational_expr -> . relational_expr GE additive_expr
    (59) relational_expr -> . additive_expr
    (60) additive_expr -> . additive_expr PLUS term
    (61) additive_expr -> . additive_expr MINUS term
    (62) additive_expr -> . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    expr                           shift and go to state 80
    logic_or_expr                  shift and go to state 51
    logic_and_expr                 shift and go to state 52
    equality_expr                  shift and go to state 53
    relational_expr                shift and go to state 54
    additive_expr                  shift and go to state 55
    term                           shift and go to state 56
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 46

    (41) while_stmt -> WHILE LPAREN . expr RPAREN block
    (47) expr -> . logic_or_expr
    (48) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (49) logic_or_expr -> . logic_and_expr
    (50) logic_and_expr -> . logic_and_expr AND equality_expr
    (51) logic_and_expr -> . equality_expr
    (52) equality_expr -> . equality_expr EQ relational_expr
    (53) equality_expr -> . equality_expr NE relational_expr
    (54) equality_expr -> . relational_expr
    (55) relational_expr -> . relational_expr LT additive_expr
    (56) relational_expr -> . relational_expr LE additive_expr
    (57) relational_expr -> . relational_expr GT additive_expr
    (58) relational_expr -> . relational_expr GE additive_expr
    (59) relational_expr -> . additive_expr
    (60) additive_expr -> . additive_expr PLUS term
    (61) additive_expr -> . additive_expr MINUS term
    (62) additive_expr -> . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    expr                           shift and go to state 81
    logic_or_expr                  shift and go to state 51
    logic_and_expr                 shift and go to state 52
    equality_expr                  shift and go to state 53
    relational_expr                shift and go to state 54
    additive_expr                  shift and go to state 55
    term                           shift and go to state 56
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 47

    (42) for_stmt -> FOR LPAREN . assignment SEMICOLON expr SEMICOLON assignment RPAREN block
    (33) assignment -> . location ASSIGN expr
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    ID              shift and go to state 83

    assignment                     shift and go to state 82
    location                       shift and go to state 25

state 48

    (43) io_stmt -> PRINT LPAREN . expr RPAREN
    (47) expr -> . logic_or_expr
    (48) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (49) logic_or_expr -> . logic_and_expr
    (50) logic_and_expr -> . logic_and_expr AND equality_expr
    (51) logic_and_expr -> . equality_expr
    (52) equality_expr -> . equality_expr EQ relational_expr
    (53) equality_expr -> . equality_expr NE relational_expr
    (54) equality_expr -> . relational_expr
    (55) relational_expr -> . relational_expr LT additive_expr
    (56) relational_expr -> . relational_expr LE additive_expr
    (57) relational_expr -> . relational_expr GT additive_expr
    (58) relational_expr -> . relational_expr GE additive_expr
    (59) relational_expr -> . additive_expr
    (60) additive_expr -> . additive_expr PLUS term
    (61) additive_expr -> . additive_expr MINUS term
    (62) additive_expr -> . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    expr                           shift and go to state 84
    logic_or_expr                  shift and go to state 51
    logic_and_expr                 shift and go to state 52
    equality_expr                  shift and go to state 53
    relational_expr                shift and go to state 54
    additive_expr                  shift and go to state 55
    term                           shift and go to state 56
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 49

    (44) io_stmt -> INPUT LPAREN . ID RPAREN

    ID              shift and go to state 85


state 50

    (45) return_stmt -> RETURN expr .

    SEMICOLON       reduce using rule 45 (return_stmt -> RETURN expr .)


state 51

    (47) expr -> logic_or_expr .
    (48) logic_or_expr -> logic_or_expr . OR logic_and_expr

    SEMICOLON       reduce using rule 47 (expr -> logic_or_expr .)
    COMMA           reduce using rule 47 (expr -> logic_or_expr .)
    RPAREN          reduce using rule 47 (expr -> logic_or_expr .)
    RBRACKET        reduce using rule 47 (expr -> logic_or_expr .)
    OR              shift and go to state 86


state 52

    (49) logic_or_expr -> logic_and_expr .
    (50) logic_and_expr -> logic_and_expr . AND equality_expr

    OR              reduce using rule 49 (logic_or_expr -> logic_and_expr .)
    SEMICOLON       reduce using rule 49 (logic_or_expr -> logic_and_expr .)
    COMMA           reduce using rule 49 (logic_or_expr -> logic_and_expr .)
    RPAREN          reduce using rule 49 (logic_or_expr -> logic_and_expr .)
    RBRACKET        reduce using rule 49 (logic_or_expr -> logic_and_expr .)
    AND             shift and go to state 87


state 53

    (51) logic_and_expr -> equality_expr .
    (52) equality_expr -> equality_expr . EQ relational_expr
    (53) equality_expr -> equality_expr . NE relational_expr

    AND             reduce using rule 51 (logic_and_expr -> equality_expr .)
    OR              reduce using rule 51 (logic_and_expr -> equality_expr .)
    SEMICOLON       reduce using rule 51 (logic_and_expr -> equality_expr .)
    COMMA           reduce using rule 51 (logic_and_expr -> equality_expr .)
    RPAREN          reduce using rule 51 (logic_and_expr -> equality_expr .)
    RBRACKET        reduce using rule 51 (logic_and_expr -> equality_expr .)
    EQ              shift and go to state 88
    NE              shift and go to state 89


state 54

    (54) equality_expr -> relational_expr .
    (55) relational_expr -> relational_expr . LT additive_expr
    (56) relational_expr -> relational_expr . LE additive_expr
    (57) relational_expr -> relational_expr . GT additive_expr
    (58) relational_expr -> relational_expr . GE additive_expr

    EQ              reduce using rule 54 (equality_expr -> relational_expr .)
    NE              reduce using rule 54 (equality_expr -> relational_expr .)
    AND             reduce using rule 54 (equality_expr -> relational_expr .)
    OR              reduce using rule 54 (equality_expr -> relational_expr .)
    SEMICOLON       reduce using rule 54 (equality_expr -> relational_expr .)
    COMMA           reduce using rule 54 (equality_expr -> relational_expr .)
    RPAREN          reduce using rule 54 (equality_expr -> relational_expr .)
    RBRACKET        reduce using rule 54 (equality_expr -> relational_expr .)
    LT              shift and go to state 90
    LE              shift and go to state 91
    GT              shift and go to state 92
    GE              shift and go to state 93


state 55

    (59) relational_expr -> additive_expr .
    (60) additive_expr -> additive_expr . PLUS term
    (61) additive_expr -> additive_expr . MINUS term

    LT              reduce using rule 59 (relational_expr -> additive_expr .)
    LE              reduce using rule 59 (relational_expr -> additive_expr .)
    GT              reduce using rule 59 (relational_expr -> additive_expr .)
    GE              reduce using rule 59 (relational_expr -> additive_expr .)
    EQ              reduce using rule 59 (relational_expr -> additive_expr .)
    NE              reduce using rule 59 (relational_expr -> additive_expr .)
    AND             reduce using rule 59 (relational_expr -> additive_expr .)
    OR              reduce using rule 59 (relational_expr -> additive_expr .)
    SEMICOLON       reduce using rule 59 (relational_expr -> additive_expr .)
    COMMA           reduce using rule 59 (relational_expr -> additive_expr .)
    RPAREN          reduce using rule 59 (relational_expr -> additive_expr .)
    RBRACKET        reduce using rule 59 (relational_expr -> additive_expr .)
    PLUS            shift and go to state 94
    MINUS           shift and go to state 95


state 56

    (62) additive_expr -> term .
    (63) term -> term . TIMES factor
    (64) term -> term . DIVIDE factor
    (65) term -> term . MOD factor

    PLUS            reduce using rule 62 (additive_expr -> term .)
    MINUS           reduce using rule 62 (additive_expr -> term .)
    LT              reduce using rule 62 (additive_expr -> term .)
    LE              reduce using rule 62 (additive_expr -> term .)
    GT              reduce using rule 62 (additive_expr -> term .)
    GE              reduce using rule 62 (additive_expr -> term .)
    EQ              reduce using rule 62 (additive_expr -> term .)
    NE              reduce using rule 62 (additive_expr -> term .)
    AND             reduce using rule 62 (additive_expr -> term .)
    OR              reduce using rule 62 (additive_expr -> term .)
    SEMICOLON       reduce using rule 62 (additive_expr -> term .)
    COMMA           reduce using rule 62 (additive_expr -> term .)
    RPAREN          reduce using rule 62 (additive_expr -> term .)
    RBRACKET        reduce using rule 62 (additive_expr -> term .)
    TIMES           shift and go to state 96
    DIVIDE          shift and go to state 97
    MOD             shift and go to state 98


state 57

    (68) factor -> MINUS . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    factor                         shift and go to state 99
    location                       shift and go to state 67

state 58

    (66) term -> factor .

    TIMES           reduce using rule 66 (term -> factor .)
    DIVIDE          reduce using rule 66 (term -> factor .)
    MOD             reduce using rule 66 (term -> factor .)
    PLUS            reduce using rule 66 (term -> factor .)
    MINUS           reduce using rule 66 (term -> factor .)
    LT              reduce using rule 66 (term -> factor .)
    LE              reduce using rule 66 (term -> factor .)
    GT              reduce using rule 66 (term -> factor .)
    GE              reduce using rule 66 (term -> factor .)
    EQ              reduce using rule 66 (term -> factor .)
    NE              reduce using rule 66 (term -> factor .)
    AND             reduce using rule 66 (term -> factor .)
    OR              reduce using rule 66 (term -> factor .)
    SEMICOLON       reduce using rule 66 (term -> factor .)
    COMMA           reduce using rule 66 (term -> factor .)
    RPAREN          reduce using rule 66 (term -> factor .)
    RBRACKET        reduce using rule 66 (term -> factor .)


state 59

    (67) factor -> NOT . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    factor                         shift and go to state 100
    location                       shift and go to state 67

state 60

    (69) factor -> LPAREN . expr RPAREN
    (47) expr -> . logic_or_expr
    (48) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (49) logic_or_expr -> . logic_and_expr
    (50) logic_and_expr -> . logic_and_expr AND equality_expr
    (51) logic_and_expr -> . equality_expr
    (52) equality_expr -> . equality_expr EQ relational_expr
    (53) equality_expr -> . equality_expr NE relational_expr
    (54) equality_expr -> . relational_expr
    (55) relational_expr -> . relational_expr LT additive_expr
    (56) relational_expr -> . relational_expr LE additive_expr
    (57) relational_expr -> . relational_expr GT additive_expr
    (58) relational_expr -> . relational_expr GE additive_expr
    (59) relational_expr -> . additive_expr
    (60) additive_expr -> . additive_expr PLUS term
    (61) additive_expr -> . additive_expr MINUS term
    (62) additive_expr -> . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    expr                           shift and go to state 101
    logic_or_expr                  shift and go to state 51
    logic_and_expr                 shift and go to state 52
    equality_expr                  shift and go to state 53
    relational_expr                shift and go to state 54
    additive_expr                  shift and go to state 55
    term                           shift and go to state 56
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 61

    (70) factor -> INT_LITERAL .

    TIMES           reduce using rule 70 (factor -> INT_LITERAL .)
    DIVIDE          reduce using rule 70 (factor -> INT_LITERAL .)
    MOD             reduce using rule 70 (factor -> INT_LITERAL .)
    PLUS            reduce using rule 70 (factor -> INT_LITERAL .)
    MINUS           reduce using rule 70 (factor -> INT_LITERAL .)
    LT              reduce using rule 70 (factor -> INT_LITERAL .)
    LE              reduce using rule 70 (factor -> INT_LITERAL .)
    GT              reduce using rule 70 (factor -> INT_LITERAL .)
    GE              reduce using rule 70 (factor -> INT_LITERAL .)
    EQ              reduce using rule 70 (factor -> INT_LITERAL .)
    NE              reduce using rule 70 (factor -> INT_LITERAL .)
    AND             reduce using rule 70 (factor -> INT_LITERAL .)
    OR              reduce using rule 70 (factor -> INT_LITERAL .)
    SEMICOLON       reduce using rule 70 (factor -> INT_LITERAL .)
    COMMA           reduce using rule 70 (factor -> INT_LITERAL .)
    RPAREN          reduce using rule 70 (factor -> INT_LITERAL .)
    RBRACKET        reduce using rule 70 (factor -> INT_LITERAL .)


state 62

    (71) factor -> FLOAT_LITERAL .

    TIMES           reduce using rule 71 (factor -> FLOAT_LITERAL .)
    DIVIDE          reduce using rule 71 (factor -> FLOAT_LITERAL .)
    MOD             reduce using rule 71 (factor -> FLOAT_LITERAL .)
    PLUS            reduce using rule 71 (factor -> FLOAT_LITERAL .)
    MINUS           reduce using rule 71 (factor -> FLOAT_LITERAL .)
    LT              reduce using rule 71 (factor -> FLOAT_LITERAL .)
    LE              reduce using rule 71 (factor -> FLOAT_LITERAL .)
    GT              reduce using rule 71 (factor -> FLOAT_LITERAL .)
    GE              reduce using rule 71 (factor -> FLOAT_LITERAL .)
    EQ              reduce using rule 71 (factor -> FLOAT_LITERAL .)
    NE              reduce using rule 71 (factor -> FLOAT_LITERAL .)
    AND             reduce using rule 71 (factor -> FLOAT_LITERAL .)
    OR              reduce using rule 71 (factor -> FLOAT_LITERAL .)
    SEMICOLON       reduce using rule 71 (factor -> FLOAT_LITERAL .)
    COMMA           reduce using rule 71 (factor -> FLOAT_LITERAL .)
    RPAREN          reduce using rule 71 (factor -> FLOAT_LITERAL .)
    RBRACKET        reduce using rule 71 (factor -> FLOAT_LITERAL .)


state 63

    (72) factor -> TRUE .

    TIMES           reduce using rule 72 (factor -> TRUE .)
    DIVIDE          reduce using rule 72 (factor -> TRUE .)
    MOD             reduce using rule 72 (factor -> TRUE .)
    PLUS            reduce using rule 72 (factor -> TRUE .)
    MINUS           reduce using rule 72 (factor -> TRUE .)
    LT              reduce using rule 72 (factor -> TRUE .)
    LE              reduce using rule 72 (factor -> TRUE .)
    GT              reduce using rule 72 (factor -> TRUE .)
    GE              reduce using rule 72 (factor -> TRUE .)
    EQ              reduce using rule 72 (factor -> TRUE .)
    NE              reduce using rule 72 (factor -> TRUE .)
    AND             reduce using rule 72 (factor -> TRUE .)
    OR              reduce using rule 72 (factor -> TRUE .)
    SEMICOLON       reduce using rule 72 (factor -> TRUE .)
    COMMA           reduce using rule 72 (factor -> TRUE .)
    RPAREN          reduce using rule 72 (factor -> TRUE .)
    RBRACKET        reduce using rule 72 (factor -> TRUE .)


state 64

    (73) factor -> FALSE .

    TIMES           reduce using rule 73 (factor -> FALSE .)
    DIVIDE          reduce using rule 73 (factor -> FALSE .)
    MOD             reduce using rule 73 (factor -> FALSE .)
    PLUS            reduce using rule 73 (factor -> FALSE .)
    MINUS           reduce using rule 73 (factor -> FALSE .)
    LT              reduce using rule 73 (factor -> FALSE .)
    LE              reduce using rule 73 (factor -> FALSE .)
    GT              reduce using rule 73 (factor -> FALSE .)
    GE              reduce using rule 73 (factor -> FALSE .)
    EQ              reduce using rule 73 (factor -> FALSE .)
    NE              reduce using rule 73 (factor -> FALSE .)
    AND             reduce using rule 73 (factor -> FALSE .)
    OR              reduce using rule 73 (factor -> FALSE .)
    SEMICOLON       reduce using rule 73 (factor -> FALSE .)
    COMMA           reduce using rule 73 (factor -> FALSE .)
    RPAREN          reduce using rule 73 (factor -> FALSE .)
    RBRACKET        reduce using rule 73 (factor -> FALSE .)


state 65

    (74) factor -> CHAR_LITERAL .

    TIMES           reduce using rule 74 (factor -> CHAR_LITERAL .)
    DIVIDE          reduce using rule 74 (factor -> CHAR_LITERAL .)
    MOD             reduce using rule 74 (factor -> CHAR_LITERAL .)
    PLUS            reduce using rule 74 (factor -> CHAR_LITERAL .)
    MINUS           reduce using rule 74 (factor -> CHAR_LITERAL .)
    LT              reduce using rule 74 (factor -> CHAR_LITERAL .)
    LE              reduce using rule 74 (factor -> CHAR_LITERAL .)
    GT              reduce using rule 74 (factor -> CHAR_LITERAL .)
    GE              reduce using rule 74 (factor -> CHAR_LITERAL .)
    EQ              reduce using rule 74 (factor -> CHAR_LITERAL .)
    NE              reduce using rule 74 (factor -> CHAR_LITERAL .)
    AND             reduce using rule 74 (factor -> CHAR_LITERAL .)
    OR              reduce using rule 74 (factor -> CHAR_LITERAL .)
    SEMICOLON       reduce using rule 74 (factor -> CHAR_LITERAL .)
    COMMA           reduce using rule 74 (factor -> CHAR_LITERAL .)
    RPAREN          reduce using rule 74 (factor -> CHAR_LITERAL .)
    RBRACKET        reduce using rule 74 (factor -> CHAR_LITERAL .)


state 66

    (75) factor -> STRING_LITERAL .

    TIMES           reduce using rule 75 (factor -> STRING_LITERAL .)
    DIVIDE          reduce using rule 75 (factor -> STRING_LITERAL .)
    MOD             reduce using rule 75 (factor -> STRING_LITERAL .)
    PLUS            reduce using rule 75 (factor -> STRING_LITERAL .)
    MINUS           reduce using rule 75 (factor -> STRING_LITERAL .)
    LT              reduce using rule 75 (factor -> STRING_LITERAL .)
    LE              reduce using rule 75 (factor -> STRING_LITERAL .)
    GT              reduce using rule 75 (factor -> STRING_LITERAL .)
    GE              reduce using rule 75 (factor -> STRING_LITERAL .)
    EQ              reduce using rule 75 (factor -> STRING_LITERAL .)
    NE              reduce using rule 75 (factor -> STRING_LITERAL .)
    AND             reduce using rule 75 (factor -> STRING_LITERAL .)
    OR              reduce using rule 75 (factor -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 75 (factor -> STRING_LITERAL .)
    COMMA           reduce using rule 75 (factor -> STRING_LITERAL .)
    RPAREN          reduce using rule 75 (factor -> STRING_LITERAL .)
    RBRACKET        reduce using rule 75 (factor -> STRING_LITERAL .)


state 67

    (76) factor -> location .

    TIMES           reduce using rule 76 (factor -> location .)
    DIVIDE          reduce using rule 76 (factor -> location .)
    MOD             reduce using rule 76 (factor -> location .)
    PLUS            reduce using rule 76 (factor -> location .)
    MINUS           reduce using rule 76 (factor -> location .)
    LT              reduce using rule 76 (factor -> location .)
    LE              reduce using rule 76 (factor -> location .)
    GT              reduce using rule 76 (factor -> location .)
    GE              reduce using rule 76 (factor -> location .)
    EQ              reduce using rule 76 (factor -> location .)
    NE              reduce using rule 76 (factor -> location .)
    AND             reduce using rule 76 (factor -> location .)
    OR              reduce using rule 76 (factor -> location .)
    SEMICOLON       reduce using rule 76 (factor -> location .)
    COMMA           reduce using rule 76 (factor -> location .)
    RPAREN          reduce using rule 76 (factor -> location .)
    RBRACKET        reduce using rule 76 (factor -> location .)


state 68

    (77) factor -> ID . LPAREN arg_list_opt RPAREN
    (34) location -> ID .
    (35) location -> ID . LBRACKET expr RBRACKET

    LPAREN          shift and go to state 102
    TIMES           reduce using rule 34 (location -> ID .)
    DIVIDE          reduce using rule 34 (location -> ID .)
    MOD             reduce using rule 34 (location -> ID .)
    PLUS            reduce using rule 34 (location -> ID .)
    MINUS           reduce using rule 34 (location -> ID .)
    LT              reduce using rule 34 (location -> ID .)
    LE              reduce using rule 34 (location -> ID .)
    GT              reduce using rule 34 (location -> ID .)
    GE              reduce using rule 34 (location -> ID .)
    EQ              reduce using rule 34 (location -> ID .)
    NE              reduce using rule 34 (location -> ID .)
    AND             reduce using rule 34 (location -> ID .)
    OR              reduce using rule 34 (location -> ID .)
    SEMICOLON       reduce using rule 34 (location -> ID .)
    COMMA           reduce using rule 34 (location -> ID .)
    RPAREN          reduce using rule 34 (location -> ID .)
    RBRACKET        reduce using rule 34 (location -> ID .)
    LBRACKET        shift and go to state 36


state 69

    (21) block -> LBRACE decl_or_stmt_list . RBRACE
    (2) decl_or_stmt_list -> decl_or_stmt_list . decl_or_stmt
    (4) decl_or_stmt -> . var_decl
    (5) decl_or_stmt -> . func_decl
    (6) decl_or_stmt -> . statement
    (7) var_decl -> . type ID SEMICOLON
    (8) var_decl -> . type ID ASSIGN expr SEMICOLON
    (9) var_decl -> . type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON
    (15) func_decl -> . FUNC ID LPAREN param_list_opt RPAREN block
    (22) statement -> . assignment SEMICOLON
    (23) statement -> . if_stmt
    (24) statement -> . while_stmt
    (25) statement -> . for_stmt
    (26) statement -> . io_stmt SEMICOLON
    (27) statement -> . return_stmt SEMICOLON
    (28) statement -> . BREAK SEMICOLON
    (29) statement -> . CONTINUE SEMICOLON
    (30) statement -> . block
    (31) statement -> . func_call SEMICOLON
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . BOOL
    (13) type -> . CHAR
    (14) type -> . STRING
    (33) assignment -> . location ASSIGN expr
    (36) if_stmt -> . IF LPAREN expr RPAREN block elif_part else_part_opt
    (41) while_stmt -> . WHILE LPAREN expr RPAREN block
    (42) for_stmt -> . FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block
    (43) io_stmt -> . PRINT LPAREN expr RPAREN
    (44) io_stmt -> . INPUT LPAREN ID RPAREN
    (45) return_stmt -> . RETURN expr
    (46) return_stmt -> . RETURN
    (21) block -> . LBRACE decl_or_stmt_list RBRACE
    (32) func_call -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    RBRACE          shift and go to state 103
    FUNC            shift and go to state 9
    BREAK           shift and go to state 17
    CONTINUE        shift and go to state 18
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    BOOL            shift and go to state 22
    CHAR            shift and go to state 23
    STRING          shift and go to state 24
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    PRINT           shift and go to state 29
    INPUT           shift and go to state 30
    RETURN          shift and go to state 31
    LBRACE          shift and go to state 32
    ID              shift and go to state 8

    decl_or_stmt                   shift and go to state 33
    var_decl                       shift and go to state 4
    func_decl                      shift and go to state 5
    statement                      shift and go to state 6
    type                           shift and go to state 7
    block                          shift and go to state 10
    assignment                     shift and go to state 11
    if_stmt                        shift and go to state 12
    while_stmt                     shift and go to state 13
    for_stmt                       shift and go to state 14
    io_stmt                        shift and go to state 15
    return_stmt                    shift and go to state 16
    func_call                      shift and go to state 19
    location                       shift and go to state 25

state 70

    (7) var_decl -> type ID SEMICOLON .

    FUNC            reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    BREAK           reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    CONTINUE        reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    INT             reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    FLOAT           reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    BOOL            reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    CHAR            reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    STRING          reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    IF              reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    WHILE           reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    FOR             reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    PRINT           reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    INPUT           reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    RETURN          reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    LBRACE          reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    ID              reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    $end            reduce using rule 7 (var_decl -> type ID SEMICOLON .)
    RBRACE          reduce using rule 7 (var_decl -> type ID SEMICOLON .)


state 71

    (8) var_decl -> type ID ASSIGN . expr SEMICOLON
    (47) expr -> . logic_or_expr
    (48) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (49) logic_or_expr -> . logic_and_expr
    (50) logic_and_expr -> . logic_and_expr AND equality_expr
    (51) logic_and_expr -> . equality_expr
    (52) equality_expr -> . equality_expr EQ relational_expr
    (53) equality_expr -> . equality_expr NE relational_expr
    (54) equality_expr -> . relational_expr
    (55) relational_expr -> . relational_expr LT additive_expr
    (56) relational_expr -> . relational_expr LE additive_expr
    (57) relational_expr -> . relational_expr GT additive_expr
    (58) relational_expr -> . relational_expr GE additive_expr
    (59) relational_expr -> . additive_expr
    (60) additive_expr -> . additive_expr PLUS term
    (61) additive_expr -> . additive_expr MINUS term
    (62) additive_expr -> . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    expr                           shift and go to state 104
    logic_or_expr                  shift and go to state 51
    logic_and_expr                 shift and go to state 52
    equality_expr                  shift and go to state 53
    relational_expr                shift and go to state 54
    additive_expr                  shift and go to state 55
    term                           shift and go to state 56
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 72

    (9) var_decl -> type ID LBRACKET . INT_LITERAL RBRACKET SEMICOLON

    INT_LITERAL     shift and go to state 105


state 73

    (32) func_call -> ID LPAREN arg_list_opt . RPAREN

    RPAREN          shift and go to state 106


state 74

    (78) arg_list_opt -> arg_list .
    (80) arg_list -> arg_list . COMMA expr

    RPAREN          reduce using rule 78 (arg_list_opt -> arg_list .)
    COMMA           shift and go to state 107


state 75

    (79) arg_list_opt -> empty .

    RPAREN          reduce using rule 79 (arg_list_opt -> empty .)


state 76

    (81) arg_list -> expr .

    COMMA           reduce using rule 81 (arg_list -> expr .)
    RPAREN          reduce using rule 81 (arg_list -> expr .)


state 77

    (35) location -> ID LBRACKET expr . RBRACKET

    RBRACKET        shift and go to state 108


state 78

    (15) func_decl -> FUNC ID LPAREN . param_list_opt RPAREN block
    (16) param_list_opt -> . param_list
    (17) param_list_opt -> . empty
    (18) param_list -> . param_list COMMA param
    (19) param_list -> . param
    (82) empty -> .
    (20) param -> . type ID
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . BOOL
    (13) type -> . CHAR
    (14) type -> . STRING

    RPAREN          reduce using rule 82 (empty -> .)
    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    BOOL            shift and go to state 22
    CHAR            shift and go to state 23
    STRING          shift and go to state 24

    param_list_opt                 shift and go to state 109
    param_list                     shift and go to state 110
    empty                          shift and go to state 111
    param                          shift and go to state 112
    type                           shift and go to state 113

state 79

    (33) assignment -> location ASSIGN expr .

    SEMICOLON       reduce using rule 33 (assignment -> location ASSIGN expr .)
    RPAREN          reduce using rule 33 (assignment -> location ASSIGN expr .)


state 80

    (36) if_stmt -> IF LPAREN expr . RPAREN block elif_part else_part_opt

    RPAREN          shift and go to state 114


state 81

    (41) while_stmt -> WHILE LPAREN expr . RPAREN block

    RPAREN          shift and go to state 115


state 82

    (42) for_stmt -> FOR LPAREN assignment . SEMICOLON expr SEMICOLON assignment RPAREN block

    SEMICOLON       shift and go to state 116


state 83

    (34) location -> ID .
    (35) location -> ID . LBRACKET expr RBRACKET

    ASSIGN          reduce using rule 34 (location -> ID .)
    LBRACKET        shift and go to state 36


state 84

    (43) io_stmt -> PRINT LPAREN expr . RPAREN

    RPAREN          shift and go to state 117


state 85

    (44) io_stmt -> INPUT LPAREN ID . RPAREN

    RPAREN          shift and go to state 118


state 86

    (48) logic_or_expr -> logic_or_expr OR . logic_and_expr
    (50) logic_and_expr -> . logic_and_expr AND equality_expr
    (51) logic_and_expr -> . equality_expr
    (52) equality_expr -> . equality_expr EQ relational_expr
    (53) equality_expr -> . equality_expr NE relational_expr
    (54) equality_expr -> . relational_expr
    (55) relational_expr -> . relational_expr LT additive_expr
    (56) relational_expr -> . relational_expr LE additive_expr
    (57) relational_expr -> . relational_expr GT additive_expr
    (58) relational_expr -> . relational_expr GE additive_expr
    (59) relational_expr -> . additive_expr
    (60) additive_expr -> . additive_expr PLUS term
    (61) additive_expr -> . additive_expr MINUS term
    (62) additive_expr -> . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    logic_and_expr                 shift and go to state 119
    equality_expr                  shift and go to state 53
    relational_expr                shift and go to state 54
    additive_expr                  shift and go to state 55
    term                           shift and go to state 56
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 87

    (50) logic_and_expr -> logic_and_expr AND . equality_expr
    (52) equality_expr -> . equality_expr EQ relational_expr
    (53) equality_expr -> . equality_expr NE relational_expr
    (54) equality_expr -> . relational_expr
    (55) relational_expr -> . relational_expr LT additive_expr
    (56) relational_expr -> . relational_expr LE additive_expr
    (57) relational_expr -> . relational_expr GT additive_expr
    (58) relational_expr -> . relational_expr GE additive_expr
    (59) relational_expr -> . additive_expr
    (60) additive_expr -> . additive_expr PLUS term
    (61) additive_expr -> . additive_expr MINUS term
    (62) additive_expr -> . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    equality_expr                  shift and go to state 120
    relational_expr                shift and go to state 54
    additive_expr                  shift and go to state 55
    term                           shift and go to state 56
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 88

    (52) equality_expr -> equality_expr EQ . relational_expr
    (55) relational_expr -> . relational_expr LT additive_expr
    (56) relational_expr -> . relational_expr LE additive_expr
    (57) relational_expr -> . relational_expr GT additive_expr
    (58) relational_expr -> . relational_expr GE additive_expr
    (59) relational_expr -> . additive_expr
    (60) additive_expr -> . additive_expr PLUS term
    (61) additive_expr -> . additive_expr MINUS term
    (62) additive_expr -> . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    relational_expr                shift and go to state 121
    additive_expr                  shift and go to state 55
    term                           shift and go to state 56
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 89

    (53) equality_expr -> equality_expr NE . relational_expr
    (55) relational_expr -> . relational_expr LT additive_expr
    (56) relational_expr -> . relational_expr LE additive_expr
    (57) relational_expr -> . relational_expr GT additive_expr
    (58) relational_expr -> . relational_expr GE additive_expr
    (59) relational_expr -> . additive_expr
    (60) additive_expr -> . additive_expr PLUS term
    (61) additive_expr -> . additive_expr MINUS term
    (62) additive_expr -> . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    relational_expr                shift and go to state 122
    additive_expr                  shift and go to state 55
    term                           shift and go to state 56
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 90

    (55) relational_expr -> relational_expr LT . additive_expr
    (60) additive_expr -> . additive_expr PLUS term
    (61) additive_expr -> . additive_expr MINUS term
    (62) additive_expr -> . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    additive_expr                  shift and go to state 123
    term                           shift and go to state 56
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 91

    (56) relational_expr -> relational_expr LE . additive_expr
    (60) additive_expr -> . additive_expr PLUS term
    (61) additive_expr -> . additive_expr MINUS term
    (62) additive_expr -> . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    additive_expr                  shift and go to state 124
    term                           shift and go to state 56
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 92

    (57) relational_expr -> relational_expr GT . additive_expr
    (60) additive_expr -> . additive_expr PLUS term
    (61) additive_expr -> . additive_expr MINUS term
    (62) additive_expr -> . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    additive_expr                  shift and go to state 125
    term                           shift and go to state 56
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 93

    (58) relational_expr -> relational_expr GE . additive_expr
    (60) additive_expr -> . additive_expr PLUS term
    (61) additive_expr -> . additive_expr MINUS term
    (62) additive_expr -> . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    additive_expr                  shift and go to state 126
    term                           shift and go to state 56
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 94

    (60) additive_expr -> additive_expr PLUS . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    term                           shift and go to state 127
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 95

    (61) additive_expr -> additive_expr MINUS . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    term                           shift and go to state 128
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 96

    (63) term -> term TIMES . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    factor                         shift and go to state 129
    location                       shift and go to state 67

state 97

    (64) term -> term DIVIDE . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    factor                         shift and go to state 130
    location                       shift and go to state 67

state 98

    (65) term -> term MOD . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    factor                         shift and go to state 131
    location                       shift and go to state 67

state 99

    (68) factor -> MINUS factor .

    TIMES           reduce using rule 68 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 68 (factor -> MINUS factor .)
    MOD             reduce using rule 68 (factor -> MINUS factor .)
    PLUS            reduce using rule 68 (factor -> MINUS factor .)
    MINUS           reduce using rule 68 (factor -> MINUS factor .)
    LT              reduce using rule 68 (factor -> MINUS factor .)
    LE              reduce using rule 68 (factor -> MINUS factor .)
    GT              reduce using rule 68 (factor -> MINUS factor .)
    GE              reduce using rule 68 (factor -> MINUS factor .)
    EQ              reduce using rule 68 (factor -> MINUS factor .)
    NE              reduce using rule 68 (factor -> MINUS factor .)
    AND             reduce using rule 68 (factor -> MINUS factor .)
    OR              reduce using rule 68 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 68 (factor -> MINUS factor .)
    COMMA           reduce using rule 68 (factor -> MINUS factor .)
    RPAREN          reduce using rule 68 (factor -> MINUS factor .)
    RBRACKET        reduce using rule 68 (factor -> MINUS factor .)


state 100

    (67) factor -> NOT factor .

    TIMES           reduce using rule 67 (factor -> NOT factor .)
    DIVIDE          reduce using rule 67 (factor -> NOT factor .)
    MOD             reduce using rule 67 (factor -> NOT factor .)
    PLUS            reduce using rule 67 (factor -> NOT factor .)
    MINUS           reduce using rule 67 (factor -> NOT factor .)
    LT              reduce using rule 67 (factor -> NOT factor .)
    LE              reduce using rule 67 (factor -> NOT factor .)
    GT              reduce using rule 67 (factor -> NOT factor .)
    GE              reduce using rule 67 (factor -> NOT factor .)
    EQ              reduce using rule 67 (factor -> NOT factor .)
    NE              reduce using rule 67 (factor -> NOT factor .)
    AND             reduce using rule 67 (factor -> NOT factor .)
    OR              reduce using rule 67 (factor -> NOT factor .)
    SEMICOLON       reduce using rule 67 (factor -> NOT factor .)
    COMMA           reduce using rule 67 (factor -> NOT factor .)
    RPAREN          reduce using rule 67 (factor -> NOT factor .)
    RBRACKET        reduce using rule 67 (factor -> NOT factor .)


state 101

    (69) factor -> LPAREN expr . RPAREN

    RPAREN          shift and go to state 132


state 102

    (77) factor -> ID LPAREN . arg_list_opt RPAREN
    (78) arg_list_opt -> . arg_list
    (79) arg_list_opt -> . empty
    (80) arg_list -> . arg_list COMMA expr
    (81) arg_list -> . expr
    (82) empty -> .
    (47) expr -> . logic_or_expr
    (48) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (49) logic_or_expr -> . logic_and_expr
    (50) logic_and_expr -> . logic_and_expr AND equality_expr
    (51) logic_and_expr -> . equality_expr
    (52) equality_expr -> . equality_expr EQ relational_expr
    (53) equality_expr -> . equality_expr NE relational_expr
    (54) equality_expr -> . relational_expr
    (55) relational_expr -> . relational_expr LT additive_expr
    (56) relational_expr -> . relational_expr LE additive_expr
    (57) relational_expr -> . relational_expr GT additive_expr
    (58) relational_expr -> . relational_expr GE additive_expr
    (59) relational_expr -> . additive_expr
    (60) additive_expr -> . additive_expr PLUS term
    (61) additive_expr -> . additive_expr MINUS term
    (62) additive_expr -> . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    RPAREN          reduce using rule 82 (empty -> .)
    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    arg_list_opt                   shift and go to state 133
    arg_list                       shift and go to state 74
    empty                          shift and go to state 75
    expr                           shift and go to state 76
    logic_or_expr                  shift and go to state 51
    logic_and_expr                 shift and go to state 52
    equality_expr                  shift and go to state 53
    relational_expr                shift and go to state 54
    additive_expr                  shift and go to state 55
    term                           shift and go to state 56
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 103

    (21) block -> LBRACE decl_or_stmt_list RBRACE .

    FUNC            reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    BREAK           reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    CONTINUE        reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    INT             reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    FLOAT           reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    BOOL            reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    CHAR            reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    STRING          reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    IF              reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    WHILE           reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    FOR             reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    PRINT           reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    INPUT           reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    RETURN          reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    LBRACE          reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    ID              reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    $end            reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    RBRACE          reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    ELIF            reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)
    ELSE            reduce using rule 21 (block -> LBRACE decl_or_stmt_list RBRACE .)


state 104

    (8) var_decl -> type ID ASSIGN expr . SEMICOLON

    SEMICOLON       shift and go to state 134


state 105

    (9) var_decl -> type ID LBRACKET INT_LITERAL . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 135


state 106

    (32) func_call -> ID LPAREN arg_list_opt RPAREN .

    SEMICOLON       reduce using rule 32 (func_call -> ID LPAREN arg_list_opt RPAREN .)


state 107

    (80) arg_list -> arg_list COMMA . expr
    (47) expr -> . logic_or_expr
    (48) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (49) logic_or_expr -> . logic_and_expr
    (50) logic_and_expr -> . logic_and_expr AND equality_expr
    (51) logic_and_expr -> . equality_expr
    (52) equality_expr -> . equality_expr EQ relational_expr
    (53) equality_expr -> . equality_expr NE relational_expr
    (54) equality_expr -> . relational_expr
    (55) relational_expr -> . relational_expr LT additive_expr
    (56) relational_expr -> . relational_expr LE additive_expr
    (57) relational_expr -> . relational_expr GT additive_expr
    (58) relational_expr -> . relational_expr GE additive_expr
    (59) relational_expr -> . additive_expr
    (60) additive_expr -> . additive_expr PLUS term
    (61) additive_expr -> . additive_expr MINUS term
    (62) additive_expr -> . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    expr                           shift and go to state 136
    logic_or_expr                  shift and go to state 51
    logic_and_expr                 shift and go to state 52
    equality_expr                  shift and go to state 53
    relational_expr                shift and go to state 54
    additive_expr                  shift and go to state 55
    term                           shift and go to state 56
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 108

    (35) location -> ID LBRACKET expr RBRACKET .

    ASSIGN          reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    TIMES           reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    MOD             reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    LT              reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    LE              reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    GT              reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    GE              reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    EQ              reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    NE              reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    AND             reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    OR              reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    SEMICOLON       reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 35 (location -> ID LBRACKET expr RBRACKET .)


state 109

    (15) func_decl -> FUNC ID LPAREN param_list_opt . RPAREN block

    RPAREN          shift and go to state 137


state 110

    (16) param_list_opt -> param_list .
    (18) param_list -> param_list . COMMA param

    RPAREN          reduce using rule 16 (param_list_opt -> param_list .)
    COMMA           shift and go to state 138


state 111

    (17) param_list_opt -> empty .

    RPAREN          reduce using rule 17 (param_list_opt -> empty .)


state 112

    (19) param_list -> param .

    COMMA           reduce using rule 19 (param_list -> param .)
    RPAREN          reduce using rule 19 (param_list -> param .)


state 113

    (20) param -> type . ID

    ID              shift and go to state 139


state 114

    (36) if_stmt -> IF LPAREN expr RPAREN . block elif_part else_part_opt
    (21) block -> . LBRACE decl_or_stmt_list RBRACE

    LBRACE          shift and go to state 32

    block                          shift and go to state 140

state 115

    (41) while_stmt -> WHILE LPAREN expr RPAREN . block
    (21) block -> . LBRACE decl_or_stmt_list RBRACE

    LBRACE          shift and go to state 32

    block                          shift and go to state 141

state 116

    (42) for_stmt -> FOR LPAREN assignment SEMICOLON . expr SEMICOLON assignment RPAREN block
    (47) expr -> . logic_or_expr
    (48) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (49) logic_or_expr -> . logic_and_expr
    (50) logic_and_expr -> . logic_and_expr AND equality_expr
    (51) logic_and_expr -> . equality_expr
    (52) equality_expr -> . equality_expr EQ relational_expr
    (53) equality_expr -> . equality_expr NE relational_expr
    (54) equality_expr -> . relational_expr
    (55) relational_expr -> . relational_expr LT additive_expr
    (56) relational_expr -> . relational_expr LE additive_expr
    (57) relational_expr -> . relational_expr GT additive_expr
    (58) relational_expr -> . relational_expr GE additive_expr
    (59) relational_expr -> . additive_expr
    (60) additive_expr -> . additive_expr PLUS term
    (61) additive_expr -> . additive_expr MINUS term
    (62) additive_expr -> . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    expr                           shift and go to state 142
    logic_or_expr                  shift and go to state 51
    logic_and_expr                 shift and go to state 52
    equality_expr                  shift and go to state 53
    relational_expr                shift and go to state 54
    additive_expr                  shift and go to state 55
    term                           shift and go to state 56
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 117

    (43) io_stmt -> PRINT LPAREN expr RPAREN .

    SEMICOLON       reduce using rule 43 (io_stmt -> PRINT LPAREN expr RPAREN .)


state 118

    (44) io_stmt -> INPUT LPAREN ID RPAREN .

    SEMICOLON       reduce using rule 44 (io_stmt -> INPUT LPAREN ID RPAREN .)


state 119

    (48) logic_or_expr -> logic_or_expr OR logic_and_expr .
    (50) logic_and_expr -> logic_and_expr . AND equality_expr

    OR              reduce using rule 48 (logic_or_expr -> logic_or_expr OR logic_and_expr .)
    SEMICOLON       reduce using rule 48 (logic_or_expr -> logic_or_expr OR logic_and_expr .)
    COMMA           reduce using rule 48 (logic_or_expr -> logic_or_expr OR logic_and_expr .)
    RPAREN          reduce using rule 48 (logic_or_expr -> logic_or_expr OR logic_and_expr .)
    RBRACKET        reduce using rule 48 (logic_or_expr -> logic_or_expr OR logic_and_expr .)
    AND             shift and go to state 87


state 120

    (50) logic_and_expr -> logic_and_expr AND equality_expr .
    (52) equality_expr -> equality_expr . EQ relational_expr
    (53) equality_expr -> equality_expr . NE relational_expr

    AND             reduce using rule 50 (logic_and_expr -> logic_and_expr AND equality_expr .)
    OR              reduce using rule 50 (logic_and_expr -> logic_and_expr AND equality_expr .)
    SEMICOLON       reduce using rule 50 (logic_and_expr -> logic_and_expr AND equality_expr .)
    COMMA           reduce using rule 50 (logic_and_expr -> logic_and_expr AND equality_expr .)
    RPAREN          reduce using rule 50 (logic_and_expr -> logic_and_expr AND equality_expr .)
    RBRACKET        reduce using rule 50 (logic_and_expr -> logic_and_expr AND equality_expr .)
    EQ              shift and go to state 88
    NE              shift and go to state 89


state 121

    (52) equality_expr -> equality_expr EQ relational_expr .
    (55) relational_expr -> relational_expr . LT additive_expr
    (56) relational_expr -> relational_expr . LE additive_expr
    (57) relational_expr -> relational_expr . GT additive_expr
    (58) relational_expr -> relational_expr . GE additive_expr

    EQ              reduce using rule 52 (equality_expr -> equality_expr EQ relational_expr .)
    NE              reduce using rule 52 (equality_expr -> equality_expr EQ relational_expr .)
    AND             reduce using rule 52 (equality_expr -> equality_expr EQ relational_expr .)
    OR              reduce using rule 52 (equality_expr -> equality_expr EQ relational_expr .)
    SEMICOLON       reduce using rule 52 (equality_expr -> equality_expr EQ relational_expr .)
    COMMA           reduce using rule 52 (equality_expr -> equality_expr EQ relational_expr .)
    RPAREN          reduce using rule 52 (equality_expr -> equality_expr EQ relational_expr .)
    RBRACKET        reduce using rule 52 (equality_expr -> equality_expr EQ relational_expr .)
    LT              shift and go to state 90
    LE              shift and go to state 91
    GT              shift and go to state 92
    GE              shift and go to state 93


state 122

    (53) equality_expr -> equality_expr NE relational_expr .
    (55) relational_expr -> relational_expr . LT additive_expr
    (56) relational_expr -> relational_expr . LE additive_expr
    (57) relational_expr -> relational_expr . GT additive_expr
    (58) relational_expr -> relational_expr . GE additive_expr

    EQ              reduce using rule 53 (equality_expr -> equality_expr NE relational_expr .)
    NE              reduce using rule 53 (equality_expr -> equality_expr NE relational_expr .)
    AND             reduce using rule 53 (equality_expr -> equality_expr NE relational_expr .)
    OR              reduce using rule 53 (equality_expr -> equality_expr NE relational_expr .)
    SEMICOLON       reduce using rule 53 (equality_expr -> equality_expr NE relational_expr .)
    COMMA           reduce using rule 53 (equality_expr -> equality_expr NE relational_expr .)
    RPAREN          reduce using rule 53 (equality_expr -> equality_expr NE relational_expr .)
    RBRACKET        reduce using rule 53 (equality_expr -> equality_expr NE relational_expr .)
    LT              shift and go to state 90
    LE              shift and go to state 91
    GT              shift and go to state 92
    GE              shift and go to state 93


state 123

    (55) relational_expr -> relational_expr LT additive_expr .
    (60) additive_expr -> additive_expr . PLUS term
    (61) additive_expr -> additive_expr . MINUS term

    LT              reduce using rule 55 (relational_expr -> relational_expr LT additive_expr .)
    LE              reduce using rule 55 (relational_expr -> relational_expr LT additive_expr .)
    GT              reduce using rule 55 (relational_expr -> relational_expr LT additive_expr .)
    GE              reduce using rule 55 (relational_expr -> relational_expr LT additive_expr .)
    EQ              reduce using rule 55 (relational_expr -> relational_expr LT additive_expr .)
    NE              reduce using rule 55 (relational_expr -> relational_expr LT additive_expr .)
    AND             reduce using rule 55 (relational_expr -> relational_expr LT additive_expr .)
    OR              reduce using rule 55 (relational_expr -> relational_expr LT additive_expr .)
    SEMICOLON       reduce using rule 55 (relational_expr -> relational_expr LT additive_expr .)
    COMMA           reduce using rule 55 (relational_expr -> relational_expr LT additive_expr .)
    RPAREN          reduce using rule 55 (relational_expr -> relational_expr LT additive_expr .)
    RBRACKET        reduce using rule 55 (relational_expr -> relational_expr LT additive_expr .)
    PLUS            shift and go to state 94
    MINUS           shift and go to state 95


state 124

    (56) relational_expr -> relational_expr LE additive_expr .
    (60) additive_expr -> additive_expr . PLUS term
    (61) additive_expr -> additive_expr . MINUS term

    LT              reduce using rule 56 (relational_expr -> relational_expr LE additive_expr .)
    LE              reduce using rule 56 (relational_expr -> relational_expr LE additive_expr .)
    GT              reduce using rule 56 (relational_expr -> relational_expr LE additive_expr .)
    GE              reduce using rule 56 (relational_expr -> relational_expr LE additive_expr .)
    EQ              reduce using rule 56 (relational_expr -> relational_expr LE additive_expr .)
    NE              reduce using rule 56 (relational_expr -> relational_expr LE additive_expr .)
    AND             reduce using rule 56 (relational_expr -> relational_expr LE additive_expr .)
    OR              reduce using rule 56 (relational_expr -> relational_expr LE additive_expr .)
    SEMICOLON       reduce using rule 56 (relational_expr -> relational_expr LE additive_expr .)
    COMMA           reduce using rule 56 (relational_expr -> relational_expr LE additive_expr .)
    RPAREN          reduce using rule 56 (relational_expr -> relational_expr LE additive_expr .)
    RBRACKET        reduce using rule 56 (relational_expr -> relational_expr LE additive_expr .)
    PLUS            shift and go to state 94
    MINUS           shift and go to state 95


state 125

    (57) relational_expr -> relational_expr GT additive_expr .
    (60) additive_expr -> additive_expr . PLUS term
    (61) additive_expr -> additive_expr . MINUS term

    LT              reduce using rule 57 (relational_expr -> relational_expr GT additive_expr .)
    LE              reduce using rule 57 (relational_expr -> relational_expr GT additive_expr .)
    GT              reduce using rule 57 (relational_expr -> relational_expr GT additive_expr .)
    GE              reduce using rule 57 (relational_expr -> relational_expr GT additive_expr .)
    EQ              reduce using rule 57 (relational_expr -> relational_expr GT additive_expr .)
    NE              reduce using rule 57 (relational_expr -> relational_expr GT additive_expr .)
    AND             reduce using rule 57 (relational_expr -> relational_expr GT additive_expr .)
    OR              reduce using rule 57 (relational_expr -> relational_expr GT additive_expr .)
    SEMICOLON       reduce using rule 57 (relational_expr -> relational_expr GT additive_expr .)
    COMMA           reduce using rule 57 (relational_expr -> relational_expr GT additive_expr .)
    RPAREN          reduce using rule 57 (relational_expr -> relational_expr GT additive_expr .)
    RBRACKET        reduce using rule 57 (relational_expr -> relational_expr GT additive_expr .)
    PLUS            shift and go to state 94
    MINUS           shift and go to state 95


state 126

    (58) relational_expr -> relational_expr GE additive_expr .
    (60) additive_expr -> additive_expr . PLUS term
    (61) additive_expr -> additive_expr . MINUS term

    LT              reduce using rule 58 (relational_expr -> relational_expr GE additive_expr .)
    LE              reduce using rule 58 (relational_expr -> relational_expr GE additive_expr .)
    GT              reduce using rule 58 (relational_expr -> relational_expr GE additive_expr .)
    GE              reduce using rule 58 (relational_expr -> relational_expr GE additive_expr .)
    EQ              reduce using rule 58 (relational_expr -> relational_expr GE additive_expr .)
    NE              reduce using rule 58 (relational_expr -> relational_expr GE additive_expr .)
    AND             reduce using rule 58 (relational_expr -> relational_expr GE additive_expr .)
    OR              reduce using rule 58 (relational_expr -> relational_expr GE additive_expr .)
    SEMICOLON       reduce using rule 58 (relational_expr -> relational_expr GE additive_expr .)
    COMMA           reduce using rule 58 (relational_expr -> relational_expr GE additive_expr .)
    RPAREN          reduce using rule 58 (relational_expr -> relational_expr GE additive_expr .)
    RBRACKET        reduce using rule 58 (relational_expr -> relational_expr GE additive_expr .)
    PLUS            shift and go to state 94
    MINUS           shift and go to state 95


state 127

    (60) additive_expr -> additive_expr PLUS term .
    (63) term -> term . TIMES factor
    (64) term -> term . DIVIDE factor
    (65) term -> term . MOD factor

    PLUS            reduce using rule 60 (additive_expr -> additive_expr PLUS term .)
    MINUS           reduce using rule 60 (additive_expr -> additive_expr PLUS term .)
    LT              reduce using rule 60 (additive_expr -> additive_expr PLUS term .)
    LE              reduce using rule 60 (additive_expr -> additive_expr PLUS term .)
    GT              reduce using rule 60 (additive_expr -> additive_expr PLUS term .)
    GE              reduce using rule 60 (additive_expr -> additive_expr PLUS term .)
    EQ              reduce using rule 60 (additive_expr -> additive_expr PLUS term .)
    NE              reduce using rule 60 (additive_expr -> additive_expr PLUS term .)
    AND             reduce using rule 60 (additive_expr -> additive_expr PLUS term .)
    OR              reduce using rule 60 (additive_expr -> additive_expr PLUS term .)
    SEMICOLON       reduce using rule 60 (additive_expr -> additive_expr PLUS term .)
    COMMA           reduce using rule 60 (additive_expr -> additive_expr PLUS term .)
    RPAREN          reduce using rule 60 (additive_expr -> additive_expr PLUS term .)
    RBRACKET        reduce using rule 60 (additive_expr -> additive_expr PLUS term .)
    TIMES           shift and go to state 96
    DIVIDE          shift and go to state 97
    MOD             shift and go to state 98


state 128

    (61) additive_expr -> additive_expr MINUS term .
    (63) term -> term . TIMES factor
    (64) term -> term . DIVIDE factor
    (65) term -> term . MOD factor

    PLUS            reduce using rule 61 (additive_expr -> additive_expr MINUS term .)
    MINUS           reduce using rule 61 (additive_expr -> additive_expr MINUS term .)
    LT              reduce using rule 61 (additive_expr -> additive_expr MINUS term .)
    LE              reduce using rule 61 (additive_expr -> additive_expr MINUS term .)
    GT              reduce using rule 61 (additive_expr -> additive_expr MINUS term .)
    GE              reduce using rule 61 (additive_expr -> additive_expr MINUS term .)
    EQ              reduce using rule 61 (additive_expr -> additive_expr MINUS term .)
    NE              reduce using rule 61 (additive_expr -> additive_expr MINUS term .)
    AND             reduce using rule 61 (additive_expr -> additive_expr MINUS term .)
    OR              reduce using rule 61 (additive_expr -> additive_expr MINUS term .)
    SEMICOLON       reduce using rule 61 (additive_expr -> additive_expr MINUS term .)
    COMMA           reduce using rule 61 (additive_expr -> additive_expr MINUS term .)
    RPAREN          reduce using rule 61 (additive_expr -> additive_expr MINUS term .)
    RBRACKET        reduce using rule 61 (additive_expr -> additive_expr MINUS term .)
    TIMES           shift and go to state 96
    DIVIDE          shift and go to state 97
    MOD             shift and go to state 98


state 129

    (63) term -> term TIMES factor .

    TIMES           reduce using rule 63 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 63 (term -> term TIMES factor .)
    MOD             reduce using rule 63 (term -> term TIMES factor .)
    PLUS            reduce using rule 63 (term -> term TIMES factor .)
    MINUS           reduce using rule 63 (term -> term TIMES factor .)
    LT              reduce using rule 63 (term -> term TIMES factor .)
    LE              reduce using rule 63 (term -> term TIMES factor .)
    GT              reduce using rule 63 (term -> term TIMES factor .)
    GE              reduce using rule 63 (term -> term TIMES factor .)
    EQ              reduce using rule 63 (term -> term TIMES factor .)
    NE              reduce using rule 63 (term -> term TIMES factor .)
    AND             reduce using rule 63 (term -> term TIMES factor .)
    OR              reduce using rule 63 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 63 (term -> term TIMES factor .)
    COMMA           reduce using rule 63 (term -> term TIMES factor .)
    RPAREN          reduce using rule 63 (term -> term TIMES factor .)
    RBRACKET        reduce using rule 63 (term -> term TIMES factor .)


state 130

    (64) term -> term DIVIDE factor .

    TIMES           reduce using rule 64 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 64 (term -> term DIVIDE factor .)
    MOD             reduce using rule 64 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 64 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 64 (term -> term DIVIDE factor .)
    LT              reduce using rule 64 (term -> term DIVIDE factor .)
    LE              reduce using rule 64 (term -> term DIVIDE factor .)
    GT              reduce using rule 64 (term -> term DIVIDE factor .)
    GE              reduce using rule 64 (term -> term DIVIDE factor .)
    EQ              reduce using rule 64 (term -> term DIVIDE factor .)
    NE              reduce using rule 64 (term -> term DIVIDE factor .)
    AND             reduce using rule 64 (term -> term DIVIDE factor .)
    OR              reduce using rule 64 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 64 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 64 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 64 (term -> term DIVIDE factor .)
    RBRACKET        reduce using rule 64 (term -> term DIVIDE factor .)


state 131

    (65) term -> term MOD factor .

    TIMES           reduce using rule 65 (term -> term MOD factor .)
    DIVIDE          reduce using rule 65 (term -> term MOD factor .)
    MOD             reduce using rule 65 (term -> term MOD factor .)
    PLUS            reduce using rule 65 (term -> term MOD factor .)
    MINUS           reduce using rule 65 (term -> term MOD factor .)
    LT              reduce using rule 65 (term -> term MOD factor .)
    LE              reduce using rule 65 (term -> term MOD factor .)
    GT              reduce using rule 65 (term -> term MOD factor .)
    GE              reduce using rule 65 (term -> term MOD factor .)
    EQ              reduce using rule 65 (term -> term MOD factor .)
    NE              reduce using rule 65 (term -> term MOD factor .)
    AND             reduce using rule 65 (term -> term MOD factor .)
    OR              reduce using rule 65 (term -> term MOD factor .)
    SEMICOLON       reduce using rule 65 (term -> term MOD factor .)
    COMMA           reduce using rule 65 (term -> term MOD factor .)
    RPAREN          reduce using rule 65 (term -> term MOD factor .)
    RBRACKET        reduce using rule 65 (term -> term MOD factor .)


state 132

    (69) factor -> LPAREN expr RPAREN .

    TIMES           reduce using rule 69 (factor -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 69 (factor -> LPAREN expr RPAREN .)
    MOD             reduce using rule 69 (factor -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 69 (factor -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 69 (factor -> LPAREN expr RPAREN .)
    LT              reduce using rule 69 (factor -> LPAREN expr RPAREN .)
    LE              reduce using rule 69 (factor -> LPAREN expr RPAREN .)
    GT              reduce using rule 69 (factor -> LPAREN expr RPAREN .)
    GE              reduce using rule 69 (factor -> LPAREN expr RPAREN .)
    EQ              reduce using rule 69 (factor -> LPAREN expr RPAREN .)
    NE              reduce using rule 69 (factor -> LPAREN expr RPAREN .)
    AND             reduce using rule 69 (factor -> LPAREN expr RPAREN .)
    OR              reduce using rule 69 (factor -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 69 (factor -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 69 (factor -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 69 (factor -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 69 (factor -> LPAREN expr RPAREN .)


state 133

    (77) factor -> ID LPAREN arg_list_opt . RPAREN

    RPAREN          shift and go to state 143


state 134

    (8) var_decl -> type ID ASSIGN expr SEMICOLON .

    FUNC            reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    BREAK           reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    CONTINUE        reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    INT             reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    FLOAT           reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    BOOL            reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    CHAR            reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    STRING          reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    IF              reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    WHILE           reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    FOR             reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    PRINT           reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    INPUT           reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    RETURN          reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    LBRACE          reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    ID              reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    $end            reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)
    RBRACE          reduce using rule 8 (var_decl -> type ID ASSIGN expr SEMICOLON .)


state 135

    (9) var_decl -> type ID LBRACKET INT_LITERAL RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 144


state 136

    (80) arg_list -> arg_list COMMA expr .

    COMMA           reduce using rule 80 (arg_list -> arg_list COMMA expr .)
    RPAREN          reduce using rule 80 (arg_list -> arg_list COMMA expr .)


state 137

    (15) func_decl -> FUNC ID LPAREN param_list_opt RPAREN . block
    (21) block -> . LBRACE decl_or_stmt_list RBRACE

    LBRACE          shift and go to state 32

    block                          shift and go to state 145

state 138

    (18) param_list -> param_list COMMA . param
    (20) param -> . type ID
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . BOOL
    (13) type -> . CHAR
    (14) type -> . STRING

    INT             shift and go to state 20
    FLOAT           shift and go to state 21
    BOOL            shift and go to state 22
    CHAR            shift and go to state 23
    STRING          shift and go to state 24

    param                          shift and go to state 146
    type                           shift and go to state 113

state 139

    (20) param -> type ID .

    COMMA           reduce using rule 20 (param -> type ID .)
    RPAREN          reduce using rule 20 (param -> type ID .)


state 140

    (36) if_stmt -> IF LPAREN expr RPAREN block . elif_part else_part_opt
    (37) elif_part -> . ELIF LPAREN expr RPAREN block elif_part
    (38) elif_part -> . empty
    (82) empty -> .

    ELIF            shift and go to state 148
    ELSE            reduce using rule 82 (empty -> .)
    FUNC            reduce using rule 82 (empty -> .)
    BREAK           reduce using rule 82 (empty -> .)
    CONTINUE        reduce using rule 82 (empty -> .)
    INT             reduce using rule 82 (empty -> .)
    FLOAT           reduce using rule 82 (empty -> .)
    BOOL            reduce using rule 82 (empty -> .)
    CHAR            reduce using rule 82 (empty -> .)
    STRING          reduce using rule 82 (empty -> .)
    IF              reduce using rule 82 (empty -> .)
    WHILE           reduce using rule 82 (empty -> .)
    FOR             reduce using rule 82 (empty -> .)
    PRINT           reduce using rule 82 (empty -> .)
    INPUT           reduce using rule 82 (empty -> .)
    RETURN          reduce using rule 82 (empty -> .)
    LBRACE          reduce using rule 82 (empty -> .)
    ID              reduce using rule 82 (empty -> .)
    $end            reduce using rule 82 (empty -> .)
    RBRACE          reduce using rule 82 (empty -> .)

    elif_part                      shift and go to state 147
    empty                          shift and go to state 149

state 141

    (41) while_stmt -> WHILE LPAREN expr RPAREN block .

    FUNC            reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    BREAK           reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    CONTINUE        reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    INT             reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    FLOAT           reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    BOOL            reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    CHAR            reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    STRING          reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    IF              reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    WHILE           reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    FOR             reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    PRINT           reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    INPUT           reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    RETURN          reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    LBRACE          reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    ID              reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    $end            reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)
    RBRACE          reduce using rule 41 (while_stmt -> WHILE LPAREN expr RPAREN block .)


state 142

    (42) for_stmt -> FOR LPAREN assignment SEMICOLON expr . SEMICOLON assignment RPAREN block

    SEMICOLON       shift and go to state 150


state 143

    (77) factor -> ID LPAREN arg_list_opt RPAREN .

    TIMES           reduce using rule 77 (factor -> ID LPAREN arg_list_opt RPAREN .)
    DIVIDE          reduce using rule 77 (factor -> ID LPAREN arg_list_opt RPAREN .)
    MOD             reduce using rule 77 (factor -> ID LPAREN arg_list_opt RPAREN .)
    PLUS            reduce using rule 77 (factor -> ID LPAREN arg_list_opt RPAREN .)
    MINUS           reduce using rule 77 (factor -> ID LPAREN arg_list_opt RPAREN .)
    LT              reduce using rule 77 (factor -> ID LPAREN arg_list_opt RPAREN .)
    LE              reduce using rule 77 (factor -> ID LPAREN arg_list_opt RPAREN .)
    GT              reduce using rule 77 (factor -> ID LPAREN arg_list_opt RPAREN .)
    GE              reduce using rule 77 (factor -> ID LPAREN arg_list_opt RPAREN .)
    EQ              reduce using rule 77 (factor -> ID LPAREN arg_list_opt RPAREN .)
    NE              reduce using rule 77 (factor -> ID LPAREN arg_list_opt RPAREN .)
    AND             reduce using rule 77 (factor -> ID LPAREN arg_list_opt RPAREN .)
    OR              reduce using rule 77 (factor -> ID LPAREN arg_list_opt RPAREN .)
    SEMICOLON       reduce using rule 77 (factor -> ID LPAREN arg_list_opt RPAREN .)
    COMMA           reduce using rule 77 (factor -> ID LPAREN arg_list_opt RPAREN .)
    RPAREN          reduce using rule 77 (factor -> ID LPAREN arg_list_opt RPAREN .)
    RBRACKET        reduce using rule 77 (factor -> ID LPAREN arg_list_opt RPAREN .)


state 144

    (9) var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .

    FUNC            reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    BREAK           reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    CONTINUE        reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    INT             reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    FLOAT           reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    BOOL            reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    CHAR            reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    STRING          reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    IF              reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    WHILE           reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    FOR             reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    PRINT           reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    INPUT           reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    RETURN          reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    LBRACE          reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    ID              reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    $end            reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 9 (var_decl -> type ID LBRACKET INT_LITERAL RBRACKET SEMICOLON .)


state 145

    (15) func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .

    FUNC            reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    BREAK           reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    CONTINUE        reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    INT             reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    FLOAT           reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    BOOL            reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    CHAR            reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    STRING          reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    IF              reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    WHILE           reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    FOR             reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    PRINT           reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    INPUT           reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    RETURN          reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    LBRACE          reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    ID              reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    $end            reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)
    RBRACE          reduce using rule 15 (func_decl -> FUNC ID LPAREN param_list_opt RPAREN block .)


state 146

    (18) param_list -> param_list COMMA param .

    COMMA           reduce using rule 18 (param_list -> param_list COMMA param .)
    RPAREN          reduce using rule 18 (param_list -> param_list COMMA param .)


state 147

    (36) if_stmt -> IF LPAREN expr RPAREN block elif_part . else_part_opt
    (39) else_part_opt -> . ELSE block
    (40) else_part_opt -> . empty
    (82) empty -> .

    ELSE            shift and go to state 152
    FUNC            reduce using rule 82 (empty -> .)
    BREAK           reduce using rule 82 (empty -> .)
    CONTINUE        reduce using rule 82 (empty -> .)
    INT             reduce using rule 82 (empty -> .)
    FLOAT           reduce using rule 82 (empty -> .)
    BOOL            reduce using rule 82 (empty -> .)
    CHAR            reduce using rule 82 (empty -> .)
    STRING          reduce using rule 82 (empty -> .)
    IF              reduce using rule 82 (empty -> .)
    WHILE           reduce using rule 82 (empty -> .)
    FOR             reduce using rule 82 (empty -> .)
    PRINT           reduce using rule 82 (empty -> .)
    INPUT           reduce using rule 82 (empty -> .)
    RETURN          reduce using rule 82 (empty -> .)
    LBRACE          reduce using rule 82 (empty -> .)
    ID              reduce using rule 82 (empty -> .)
    $end            reduce using rule 82 (empty -> .)
    RBRACE          reduce using rule 82 (empty -> .)

    else_part_opt                  shift and go to state 151
    empty                          shift and go to state 153

state 148

    (37) elif_part -> ELIF . LPAREN expr RPAREN block elif_part

    LPAREN          shift and go to state 154


state 149

    (38) elif_part -> empty .

    ELSE            reduce using rule 38 (elif_part -> empty .)
    FUNC            reduce using rule 38 (elif_part -> empty .)
    BREAK           reduce using rule 38 (elif_part -> empty .)
    CONTINUE        reduce using rule 38 (elif_part -> empty .)
    INT             reduce using rule 38 (elif_part -> empty .)
    FLOAT           reduce using rule 38 (elif_part -> empty .)
    BOOL            reduce using rule 38 (elif_part -> empty .)
    CHAR            reduce using rule 38 (elif_part -> empty .)
    STRING          reduce using rule 38 (elif_part -> empty .)
    IF              reduce using rule 38 (elif_part -> empty .)
    WHILE           reduce using rule 38 (elif_part -> empty .)
    FOR             reduce using rule 38 (elif_part -> empty .)
    PRINT           reduce using rule 38 (elif_part -> empty .)
    INPUT           reduce using rule 38 (elif_part -> empty .)
    RETURN          reduce using rule 38 (elif_part -> empty .)
    LBRACE          reduce using rule 38 (elif_part -> empty .)
    ID              reduce using rule 38 (elif_part -> empty .)
    $end            reduce using rule 38 (elif_part -> empty .)
    RBRACE          reduce using rule 38 (elif_part -> empty .)


state 150

    (42) for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON . assignment RPAREN block
    (33) assignment -> . location ASSIGN expr
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    ID              shift and go to state 83

    assignment                     shift and go to state 155
    location                       shift and go to state 25

state 151

    (36) if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .

    FUNC            reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    BREAK           reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    CONTINUE        reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    INT             reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    FLOAT           reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    BOOL            reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    CHAR            reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    STRING          reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    IF              reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    WHILE           reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    FOR             reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    PRINT           reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    INPUT           reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    RETURN          reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    LBRACE          reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    ID              reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    $end            reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)
    RBRACE          reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN block elif_part else_part_opt .)


state 152

    (39) else_part_opt -> ELSE . block
    (21) block -> . LBRACE decl_or_stmt_list RBRACE

    LBRACE          shift and go to state 32

    block                          shift and go to state 156

state 153

    (40) else_part_opt -> empty .

    FUNC            reduce using rule 40 (else_part_opt -> empty .)
    BREAK           reduce using rule 40 (else_part_opt -> empty .)
    CONTINUE        reduce using rule 40 (else_part_opt -> empty .)
    INT             reduce using rule 40 (else_part_opt -> empty .)
    FLOAT           reduce using rule 40 (else_part_opt -> empty .)
    BOOL            reduce using rule 40 (else_part_opt -> empty .)
    CHAR            reduce using rule 40 (else_part_opt -> empty .)
    STRING          reduce using rule 40 (else_part_opt -> empty .)
    IF              reduce using rule 40 (else_part_opt -> empty .)
    WHILE           reduce using rule 40 (else_part_opt -> empty .)
    FOR             reduce using rule 40 (else_part_opt -> empty .)
    PRINT           reduce using rule 40 (else_part_opt -> empty .)
    INPUT           reduce using rule 40 (else_part_opt -> empty .)
    RETURN          reduce using rule 40 (else_part_opt -> empty .)
    LBRACE          reduce using rule 40 (else_part_opt -> empty .)
    ID              reduce using rule 40 (else_part_opt -> empty .)
    $end            reduce using rule 40 (else_part_opt -> empty .)
    RBRACE          reduce using rule 40 (else_part_opt -> empty .)


state 154

    (37) elif_part -> ELIF LPAREN . expr RPAREN block elif_part
    (47) expr -> . logic_or_expr
    (48) logic_or_expr -> . logic_or_expr OR logic_and_expr
    (49) logic_or_expr -> . logic_and_expr
    (50) logic_and_expr -> . logic_and_expr AND equality_expr
    (51) logic_and_expr -> . equality_expr
    (52) equality_expr -> . equality_expr EQ relational_expr
    (53) equality_expr -> . equality_expr NE relational_expr
    (54) equality_expr -> . relational_expr
    (55) relational_expr -> . relational_expr LT additive_expr
    (56) relational_expr -> . relational_expr LE additive_expr
    (57) relational_expr -> . relational_expr GT additive_expr
    (58) relational_expr -> . relational_expr GE additive_expr
    (59) relational_expr -> . additive_expr
    (60) additive_expr -> . additive_expr PLUS term
    (61) additive_expr -> . additive_expr MINUS term
    (62) additive_expr -> . term
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) term -> . term MOD factor
    (66) term -> . factor
    (67) factor -> . NOT factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expr RPAREN
    (70) factor -> . INT_LITERAL
    (71) factor -> . FLOAT_LITERAL
    (72) factor -> . TRUE
    (73) factor -> . FALSE
    (74) factor -> . CHAR_LITERAL
    (75) factor -> . STRING_LITERAL
    (76) factor -> . location
    (77) factor -> . ID LPAREN arg_list_opt RPAREN
    (34) location -> . ID
    (35) location -> . ID LBRACKET expr RBRACKET

    NOT             shift and go to state 59
    MINUS           shift and go to state 57
    LPAREN          shift and go to state 60
    INT_LITERAL     shift and go to state 61
    FLOAT_LITERAL   shift and go to state 62
    TRUE            shift and go to state 63
    FALSE           shift and go to state 64
    CHAR_LITERAL    shift and go to state 65
    STRING_LITERAL  shift and go to state 66
    ID              shift and go to state 68

    expr                           shift and go to state 157
    logic_or_expr                  shift and go to state 51
    logic_and_expr                 shift and go to state 52
    equality_expr                  shift and go to state 53
    relational_expr                shift and go to state 54
    additive_expr                  shift and go to state 55
    term                           shift and go to state 56
    factor                         shift and go to state 58
    location                       shift and go to state 67

state 155

    (42) for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment . RPAREN block

    RPAREN          shift and go to state 158


state 156

    (39) else_part_opt -> ELSE block .

    FUNC            reduce using rule 39 (else_part_opt -> ELSE block .)
    BREAK           reduce using rule 39 (else_part_opt -> ELSE block .)
    CONTINUE        reduce using rule 39 (else_part_opt -> ELSE block .)
    INT             reduce using rule 39 (else_part_opt -> ELSE block .)
    FLOAT           reduce using rule 39 (else_part_opt -> ELSE block .)
    BOOL            reduce using rule 39 (else_part_opt -> ELSE block .)
    CHAR            reduce using rule 39 (else_part_opt -> ELSE block .)
    STRING          reduce using rule 39 (else_part_opt -> ELSE block .)
    IF              reduce using rule 39 (else_part_opt -> ELSE block .)
    WHILE           reduce using rule 39 (else_part_opt -> ELSE block .)
    FOR             reduce using rule 39 (else_part_opt -> ELSE block .)
    PRINT           reduce using rule 39 (else_part_opt -> ELSE block .)
    INPUT           reduce using rule 39 (else_part_opt -> ELSE block .)
    RETURN          reduce using rule 39 (else_part_opt -> ELSE block .)
    LBRACE          reduce using rule 39 (else_part_opt -> ELSE block .)
    ID              reduce using rule 39 (else_part_opt -> ELSE block .)
    $end            reduce using rule 39 (else_part_opt -> ELSE block .)
    RBRACE          reduce using rule 39 (else_part_opt -> ELSE block .)


state 157

    (37) elif_part -> ELIF LPAREN expr . RPAREN block elif_part

    RPAREN          shift and go to state 159


state 158

    (42) for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN . block
    (21) block -> . LBRACE decl_or_stmt_list RBRACE

    LBRACE          shift and go to state 32

    block                          shift and go to state 160

state 159

    (37) elif_part -> ELIF LPAREN expr RPAREN . block elif_part
    (21) block -> . LBRACE decl_or_stmt_list RBRACE

    LBRACE          shift and go to state 32

    block                          shift and go to state 161

state 160

    (42) for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .

    FUNC            reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    BREAK           reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    CONTINUE        reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    INT             reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    FLOAT           reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    BOOL            reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    CHAR            reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    STRING          reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    IF              reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    WHILE           reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    FOR             reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    PRINT           reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    INPUT           reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    RETURN          reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    LBRACE          reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    ID              reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    $end            reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)
    RBRACE          reduce using rule 42 (for_stmt -> FOR LPAREN assignment SEMICOLON expr SEMICOLON assignment RPAREN block .)


state 161

    (37) elif_part -> ELIF LPAREN expr RPAREN block . elif_part
    (37) elif_part -> . ELIF LPAREN expr RPAREN block elif_part
    (38) elif_part -> . empty
    (82) empty -> .

    ELIF            shift and go to state 148
    ELSE            reduce using rule 82 (empty -> .)
    FUNC            reduce using rule 82 (empty -> .)
    BREAK           reduce using rule 82 (empty -> .)
    CONTINUE        reduce using rule 82 (empty -> .)
    INT             reduce using rule 82 (empty -> .)
    FLOAT           reduce using rule 82 (empty -> .)
    BOOL            reduce using rule 82 (empty -> .)
    CHAR            reduce using rule 82 (empty -> .)
    STRING          reduce using rule 82 (empty -> .)
    IF              reduce using rule 82 (empty -> .)
    WHILE           reduce using rule 82 (empty -> .)
    FOR             reduce using rule 82 (empty -> .)
    PRINT           reduce using rule 82 (empty -> .)
    INPUT           reduce using rule 82 (empty -> .)
    RETURN          reduce using rule 82 (empty -> .)
    LBRACE          reduce using rule 82 (empty -> .)
    ID              reduce using rule 82 (empty -> .)
    $end            reduce using rule 82 (empty -> .)
    RBRACE          reduce using rule 82 (empty -> .)

    elif_part                      shift and go to state 162
    empty                          shift and go to state 149

state 162

    (37) elif_part -> ELIF LPAREN expr RPAREN block elif_part .

    ELSE            reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    FUNC            reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    BREAK           reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    CONTINUE        reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    INT             reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    FLOAT           reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    BOOL            reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    CHAR            reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    STRING          reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    IF              reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    WHILE           reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    FOR             reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    PRINT           reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    INPUT           reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    RETURN          reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    LBRACE          reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    ID              reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    $end            reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)
    RBRACE          reduce using rule 37 (elif_part -> ELIF LPAREN expr RPAREN block elif_part .)

